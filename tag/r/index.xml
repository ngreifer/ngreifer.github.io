<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>R | Noah Greifer</title>
    <link>https://ngreifer.github.io/tag/r/</link>
      <atom:link href="https://ngreifer.github.io/tag/r/index.xml" rel="self" type="application/rss+xml" />
    <description>R</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><lastBuildDate>Thu, 21 Mar 2024 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://ngreifer.github.io/media/sharing.jpg</url>
      <title>R</title>
      <link>https://ngreifer.github.io/tag/r/</link>
    </image>
    
    <item>
      <title>What&#39;s New in `WeightIt` Version 1.0.0</title>
      <link>https://ngreifer.github.io/blog/what-s-new-in-weightit-version-1-0-0/</link>
      <pubDate>Thu, 21 Mar 2024 00:00:00 +0000</pubDate>
      <guid>https://ngreifer.github.io/blog/what-s-new-in-weightit-version-1-0-0/</guid>
      <description>


&lt;p&gt;My R package &lt;a href=&#34;https://ngreifer.github.io/WeightIt/&#34;&gt;&lt;code&gt;WeightIt&lt;/code&gt;&lt;/a&gt; has a huge new update, making it one of the biggest updates since I started the project. Version 1.0.0 introduces a few breaking changes, including the possibility that old results will not align with results from newer version of the package. In most cases, though, this only means improvements (i.e., better balance).&lt;/p&gt;
&lt;p&gt;For those that don‚Äôt know, &lt;code&gt;WeightIt&lt;/code&gt; is an R package designed to provide access to propensity score weighting (also known as inverse probability weighting) and its variations in a way that facilitates the use of advanced and modern methods and best practices. It provides a simple, unified interface to many different methods of estimating weights to balance groups in observational studies, including those that use generalized linear models, machine learning methods, and convex optimization. &lt;code&gt;WeightIt&lt;/code&gt; provides support for binary, multi-category, continuous, and longitudinal treatments and directly interfaces with &lt;a href=&#34;https://ngreifer.github.io/cobalt/&#34;&gt;&lt;code&gt;cobalt&lt;/code&gt;&lt;/a&gt; for assessing balance after weighting.&lt;/p&gt;
&lt;p&gt;Version 1.0.0 has several new features that I wanted to explain in a blog post rather than just in the &lt;a href=&#34;https://ngreifer.github.io/WeightIt/news/index.html&#34;&gt;NEWS&lt;/a&gt; document associated with the package because it‚Äôs important to me that these new features are appreciated. There are three primary updates that I‚Äôll discuss, along with some minor ones. Those three are updates to the covariate balancing propensity score, a new method called inverse probability tilting, and new support for fitting weighted outcome regression models that account for estimation of the weights in the standard errors.&lt;/p&gt;
&lt;div id=&#34;new-implementation-of-cbps&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;New implementation of CBPS&lt;/h2&gt;
&lt;p&gt;The covariate balancing propensity score &lt;span class=&#34;citation&#34;&gt;(CBPS, &lt;a href=&#34;#ref-imai2014&#34;&gt;Imai and Ratkovic 2014&lt;/a&gt;)&lt;/span&gt; is a method of estimating propensity scores using generalized linear models (e.g., logistic regression). I described CBPS in my &lt;a href=&#34;https://ngreifer.github.io/blog/logistic-regression-cbps-overlap-weights/&#34;&gt;last blog post&lt;/a&gt;, so I‚Äôll be brief here. Essentially, you have the score equations for a logistic regression, the roots of which are the logistic regression coefficients. You also have moment conditions that correspond to mean balance on the included covariates in the weighted sample. There are two versions of CBPS: the just-identified version, which finds the logistic regression coefficients that only solve the balance moment conditions, and the over-identified version, which finds the logistic regression coefficients that attempt to solve both the logistic regression score equations and the balance moments conditions. Because in general it is impossible to solve both sets of conditions exactly with a single set of coefficients, the conditions are weighted in a specific way to manage the trade-off between achieving balance and maximizing the likelihood using generalized method of moments (GMM) estimation. The form of this weighting occurs with a weighting matrix, which is a function of the coefficients and can either be estimated once, in what is called the ‚Äútwo-step‚Äù estimator, or it can be continuously updated as the coefficients are estimated.&lt;/p&gt;
&lt;p&gt;There are versions of CBPS for the ATT, ATC, and ATE (logistic regression on its own &lt;a href=&#34;https://ngreifer.github.io/blog/logistic-regression-cbps-overlap-weights/#:~:text=This%20is%20why%20there%20is%20no%20%E2%80%9CATO%E2%80%9D%20option%20when%20using%20CBPS%3B%20the%20usual%20logistic%20regression%20propensity%20scores%20are%20covariate%20balancing%20propensity%20scores%20when%20targeting%20the%20ATO!&#34;&gt;is a CBPS for the ATO&lt;/a&gt;), as well as versions for multi-category and continuous treatments. The multi-category version replaces the logistic regression coefficients with coefficients in a multinomial logistic regression, and the continuous treatment version replaces the logistic regression coefficients with linear regression coefficients for the generalized propensity score &lt;span class=&#34;citation&#34;&gt;(&lt;a href=&#34;#ref-fongCovariateBalancingPropensity2018&#34;&gt;Fong, Hazlett, and Imai 2018&lt;/a&gt;)&lt;/span&gt;. There is also a version for longitudinal treatments &lt;span class=&#34;citation&#34;&gt;(&lt;a href=&#34;#ref-imaiRobustEstimationInverse2015&#34;&gt;Imai and Ratkovic 2015&lt;/a&gt;)&lt;/span&gt;, but that has never been supported by &lt;code&gt;WeightIt&lt;/code&gt; so I won‚Äôt discuss it here.&lt;/p&gt;
&lt;p&gt;Previously, estimating the CBPS propensity scores and weights by specifying &lt;code&gt;method = &#34;cbps&#34;&lt;/code&gt; in &lt;code&gt;weightit()&lt;/code&gt; was done entirely in the &lt;code&gt;CBPS&lt;/code&gt; package, which was written by the developers of the method. The package is great and does what it claims to do, but its code is very hard to read and debug, it is not very customizable, and there are ways in which the package is limited or buggy. I decided to finally figure out what CBPS was for myself as part of a broader task of understanding M-estimation (discussed later), and in doing so I realized I had the skills to program my own CBPS, and so that‚Äôs what I did, taking some inspiration from the original package. This means you can use CBPS in &lt;code&gt;WeightIt&lt;/code&gt; without requiring &lt;code&gt;CBPS&lt;/code&gt; as a dependency, and there are some additional options not available in &lt;code&gt;CBPS&lt;/code&gt; that are now available to &lt;code&gt;WeightIt&lt;/code&gt; users. I‚Äôll outline the main changes below:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The default methods are now different, which is important when comparing the output of &lt;code&gt;weightit()&lt;/code&gt; to that of &lt;code&gt;CBPS::CBPS()&lt;/code&gt; or versions of &lt;code&gt;WeightIt&lt;/code&gt; prior to 1.0.0. Now, the default is to use the just-identified version of CBPS, whereas previously the default was the over-identified version. The just-identified version has several benefits: 1) it is faster (since the over-identified version has to fit the just-identified version first anyway), 2) it yields better balance on the means, and 3) it is compatible with using M-estimation to account for uncertainty in the weights. It is still possible to request the over-identified version by setting &lt;code&gt;over = TRUE&lt;/code&gt;, and whether the two-step estimator is to be used can be controlled by the &lt;code&gt;twostep&lt;/code&gt; argument, which has the same default behavior as previously (&lt;code&gt;TRUE&lt;/code&gt; by default, which is faster but potentially less accurate).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;With multi-category treatments, the ATT and ATE can be targeted natively and the estimation supports any number of treatment groups. Previously, CBPS for the ATT and for more than 4 groups were only supported in an &lt;em&gt;ad hoc&lt;/em&gt; way because these options are not available in the &lt;code&gt;CBPS&lt;/code&gt; package. Now they are programmed directly in, so the results for them align with what one would expect based on theory. It should also be much faster to run because only one optimization is required (whereas previously multiple calls to &lt;code&gt;CBPS::CBPS()&lt;/code&gt; were required). There was also a bug in the over-identified version of the CBPS for multi-category treatments in the &lt;code&gt;CBPS&lt;/code&gt; package; it turns out this bug nudged the coefficients toward better balance, which is usually a good thing, but it meant they no longer lined up with what you would expect based on theory. This bug is not present in the new &lt;code&gt;WeightIt&lt;/code&gt; implementation.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;With continuous treatments, the weighting matrix for the over-identified CBPS now has a slightly different form from that in &lt;code&gt;CBPS&lt;/code&gt;. (Specifically, it does not integrate out the treatment, which is done for the other treatment types). This makes it more likely to converge. That said, one should probably always use the just-identified version.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Link functions other than logit are allowed for binary treatments. The CBPS as described in &lt;span class=&#34;citation&#34;&gt;Imai and Ratkovic (&lt;a href=&#34;#ref-imai2014&#34;&gt;2014&lt;/a&gt;)&lt;/span&gt; was general enough that any generalized linear model could be used, but focus was primarily on logistic regression because it is the most common model for binary outcomes. The &lt;code&gt;CBPS&lt;/code&gt; package only supports logistic regression. &lt;code&gt;WeightIt&lt;/code&gt; supports almost any link (in particular, logit, probit, complimentary log-log, cauchit, log, and identity). It turns out these are very easy to implement; the only differences are changing the inverse link used to compute the propensity scores and modifying the logistic regression score equations to include additional terms that are required for non-canonical links. In practice, logistic regression is all one should need, but it is nice to have these other options available in case you get better balance or precision using one of them, just as is the case when using propensity scores estimated from generalized linear models alone.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Some things are missing from the original CBPS implementation, though. Any other arguments to &lt;code&gt;CBPS::CBPS()&lt;/code&gt; (e.g., &lt;code&gt;baseline.formula&lt;/code&gt; and &lt;code&gt;diff.formula&lt;/code&gt;) are no longer supported, and any auxiliary CBPS outputs, like the regression coefficients on the scale of the original predictors or the J-statistic for testing the over-identification conditions, are no longer returned. I doubt these are considered by most users of CBPS, so I didn‚Äôt want to spend time computing them and returning them when people just want the propensity scores and weights. If you do want these values, let me know and I‚Äôll add them in, or just use &lt;code&gt;CBPS()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;I‚Äôm really proud of this implementation of CBPS, as it represents a culmination of my recent learning about M-estimation and generalized method of moments. There is still plenty about CBPS theory I don‚Äôt understand, but I‚Äôm happy to reduce a dependency and take charge of new advancements on the method and its implementation. I give great acknowledgement to the original authors of all papers explaining CBPS and to the developers and maintainers of the CBPS package, especially Kosuke Imai and Christian Fong, who have long supported my work and appreciated its value. I also want to thank Syd Amerikaner on CrossValidated, who &lt;a href=&#34;https://stats.stackexchange.com/q/641993/116195&#34;&gt;provided&lt;/a&gt; a key insight that helped me program the over-identified estimators.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;new-weighting-method-inverse-probability-tilting-ipt&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;New weighting method: inverse probability tilting (IPT)&lt;/h2&gt;
&lt;p&gt;IPT is a method of estimating propensity score weights described by &lt;span class=&#34;citation&#34;&gt;Graham, De Xavier Pinto, and Egel (&lt;a href=&#34;#ref-grahamInverseProbabilityTilting2012&#34;&gt;2012&lt;/a&gt;)&lt;/span&gt;. It works almost identically to the just-identified CBPS: estimating equations corresponding to covariate balance are specified, and their roots, which correspond to coefficients in a generalized linear model for the propensity score, are found and used to compute the estimated propensity scores. For the ATT and ATC, the implementation is identical to the just-identified CBPS. For the ATE, IPT uses a slightly different method which estimates propensity scores for the treated and control units separately to ensure exact mean balance not just between the treatment groups but also between each group and the original sample &lt;span class=&#34;citation&#34;&gt;(so-called ‚Äúthree-way balance,‚Äù &lt;a href=&#34;#ref-chanGloballyEfficientNonparametric2016&#34;&gt;Chan, Yam, and Zhang 2016&lt;/a&gt;)&lt;/span&gt;. The original paper on IPT only described the method for ‚Äúmissing data problems‚Äù, which usually means estimating a counterfactual mean in an ATE framework, but &lt;span class=&#34;citation&#34;&gt;Sant‚ÄôAnna and Zhao (&lt;a href=&#34;#ref-santannaDoublyRobustDifferenceindifferences2020&#34;&gt;2020&lt;/a&gt;)&lt;/span&gt; describe a version for the ATT that is just as easy to implement. For multi-category treatments, rather than fitting a multinomial logistic regression model like CBPS does, IPT does something like fitting a logistic regression model for each category. This again guarantees three-way balance, but differs from the CBPS implementation.&lt;/p&gt;
&lt;p&gt;Previously, IPT was not available in any package in R. I wrote a &lt;a href=&#34;https://gist.github.com/ngreifer/ef34ff2ef7b0ea8214fe2c6b5a080450&#34;&gt;gist&lt;/a&gt; to implement it before I really understood what it was, but now it is fully available in &lt;code&gt;WeightIt&lt;/code&gt; by setting &lt;code&gt;method = &#34;ipt&#34;&lt;/code&gt; in &lt;code&gt;weightit()&lt;/code&gt;. Its only dependency is the &lt;code&gt;rootSolve&lt;/code&gt; package, which quickly finds the roots of score equations. I could have just used &lt;code&gt;optim()&lt;/code&gt; like I did with CBPS and entropy balancing, but &lt;code&gt;rootSolve&lt;/code&gt; is quite a bit faster and often more reliable. As with CBPS, links besides the logit link are available, and all methods are compatible with M-estimation.&lt;/p&gt;
&lt;p&gt;The original authors proposed a specification test that involves testing whether the coefficients for the treated and control groups in the ATE differ from each other, and that is available in their Stata package. I didn‚Äôt put it into &lt;code&gt;WeightIt&lt;/code&gt;, but it wouldn‚Äôt be crazy to implement, so, again, let me know if you‚Äôre interested.&lt;/p&gt;
&lt;p&gt;In general, I would recommend IPT over CBPS and entropy balancing for binary and multi-category treatments due to its speed and some theoretical advantages. For all estimands, IPT is doubly robust, meaning if the link function is correctly specified or the outcome model is linear in the covariates, the estimate is consistent. For the ATE, entropy balancing doesn‚Äôt retain this property, and CBPS is less protected against incidental error in the presence of heavy effect modification. Entropy balancing is best suited for continuous treatments (IPT doesn‚Äôt even have a version for continuous treatments), as the limitations of the linear model used in CBPS prevent certain important balancing conditions from being satisfied.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;fitting-weighted-regression-models&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Fitting Weighted Regression Models&lt;/h2&gt;
&lt;p&gt;Okay, this is probably the biggest of the three biggest updates. &lt;code&gt;WeightIt&lt;/code&gt; now has functionality to fit weighted outcome regression models in a way so that the uncertainty in the estimation of the weights is accounted for in the variance matrix of the estimated parameters. This is huge because all otherwise accessible methods for estimating the variance of regression parameters after weighting treat the weights as fixed, which in most cases yields inferences that are too conservative &lt;span class=&#34;citation&#34;&gt;(i.e., inappropriately too imprecise, &lt;a href=&#34;#ref-austinBootstrapVsAsymptotic2022&#34;&gt;Austin 2022&lt;/a&gt;)&lt;/span&gt;, and in some cases yields inferences that are anti-conservative &lt;span class=&#34;citation&#34;&gt;(inappropriately too precise, &lt;a href=&#34;#ref-reifeisVarianceTreatmentEffect2022&#34;&gt;Reifeis and Hudgens 2022&lt;/a&gt;)&lt;/span&gt;. This functionality is facilitated through the new function &lt;code&gt;glm_weightit()&lt;/code&gt; (and its wrapper, &lt;code&gt;lm_weightit()&lt;/code&gt;), which are mostly wrappers around &lt;code&gt;glm()&lt;/code&gt;, but estimate the variance matrix in a away that incorporates information about the estimation of the weights. This is done in a few ways, but the most notable is through M-estimation, which I briefly mentioned above.&lt;/p&gt;
&lt;p&gt;M-estimation is a way of estimating a system of estimating equations in which the parameters can have arbitrary relationships, including across models. In this case, the parameters of the weighted outcome model depend on the weights, which in turn depend on the parameters used to estimate the weights (e.g., the coefficients in the propensity score model). By combining the estimating equations for the weight models and the estimating equations for the outcome model, we can fully account for uncertainty in both models when computing the variance of the outcome model parameters. This means that when we use g-computation based on the outcome model, we get a treatment effect estimate, the standard error of which correctly accounts for uncertainty in estimation of the weights.&lt;/p&gt;
&lt;p&gt;The way this works is as follows: one uses &lt;code&gt;weightit()&lt;/code&gt; or &lt;code&gt;weightitMSM()&lt;/code&gt; to estimate the balancing weights, and then one fits a model using &lt;code&gt;glm_weightit()&lt;/code&gt; with the output of &lt;code&gt;weightit()&lt;/code&gt; or &lt;code&gt;weightitMSM()&lt;/code&gt; supplied to the &lt;code&gt;weightit&lt;/code&gt; argument. This fits a weighted regression model using &lt;code&gt;glm()&lt;/code&gt;, and, if available, estimates the variance matrix using M-estimation. Components in the &lt;code&gt;weightit&lt;/code&gt; object contain the required information to account for the uncertainty of the weights in estimation of the variance of the outcome model parameters.&lt;/p&gt;
&lt;p&gt;This is only available for methods that support M-estimation, which unfortunately does not include all of them. Only estimation of weights using GLM propensity scores, entropy balancing, IPT, and just-identified CBPS are supported. This is still a pretty good list. For the others, the default is to return the HC0 robust variance matrix, which treats the weights as fixed but is robust to heteroscedasticity or other misspecification of the outcome model likelihood (the is also true of the M-estimation variance).&lt;/p&gt;
&lt;p&gt;Currently, no other package in R lets you do this, despite many recommendations for more accurate standard error estimation in the literature &lt;span class=&#34;citation&#34;&gt;(&lt;a href=&#34;#ref-reifeisVarianceTreatmentEffect2022&#34;&gt;Reifeis and Hudgens 2022&lt;/a&gt;; &lt;a href=&#34;#ref-austinBootstrapVsAsymptotic2022&#34;&gt;Austin 2022&lt;/a&gt;; &lt;a href=&#34;#ref-luncefordStratificationWeightingPropensity2004&#34;&gt;Lunceford and Davidian 2004&lt;/a&gt;; &lt;a href=&#34;#ref-williamsonVarianceReductionRandomised2014&#34;&gt;Williamson, Forbes, and White 2014&lt;/a&gt;; &lt;a href=&#34;#ref-gabrielInverseProbabilityTreatment2024&#34;&gt;Gabriel et al. 2024&lt;/a&gt;)&lt;/span&gt;. You would have to program this manually yourself or use the highly context-specific code provided in these articles. Other packages, in particular &lt;code&gt;PSweight&lt;/code&gt;, do allow you to estimate treatment effects that account for estimation of the weights in the standard error of the treatment effect, but only for the weighted difference in means or augmented inverse probability weighting (AIPW) (i.e., not for weighted g-computation) and only for GLM-based propensity scores. Stata offers &lt;code&gt;teffects ipwra&lt;/code&gt;, which provides the corrected standard error estimates for weighted g-computation-based estimates of the treatment effect, but it also only supports GLM propensity scores and a few estimands.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;glm_weightit()&lt;/code&gt; supports another method of estimating uncertainty, and that is the bootstrap. Both the traditional bootstrap and the fractional weighted bootstrap &lt;span class=&#34;citation&#34;&gt;(&lt;a href=&#34;#ref-xuApplicationsFractionalRandomWeightBootstrap2020a&#34;&gt;Xu et al. 2020&lt;/a&gt;)&lt;/span&gt; are supported. These bootstrap the original data, estimate the weights, and estimate the weighted outcome model automatically. Previously, one would have to program the bootstrap themselves, which wasn‚Äôt really that hard, but now this is done in one single function call. The bootstrap confidence intervals computed are Wald-type intervals, though, which perform worse than more advanced types like the BCa interval. Still, though, because the estimators are asymptotically normal, the Wald-type intervals should work well. I recommend using the fractional weighted bootstrap when possible rather than the traditional bootstrap. The choice of variance estimator is controlled by the &lt;code&gt;vcov&lt;/code&gt; argument.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;glm_weightit()&lt;/code&gt; also supports estimation of multinomial logistic regression models by setting &lt;code&gt;family = &#34;multinomial&#34;&lt;/code&gt;. The outcome model can be flexible, e.g., including polynomials or splines, and its output is compatible with most regression post-processing functions, including all functions in &lt;code&gt;marginaleffects&lt;/code&gt;, which can be used to perform g-computation to estimate the treatment effect. &lt;code&gt;glm_weightit()&lt;/code&gt; also has support for clustered covariance matrices for all variance estimation methods. My hope is to add support for fitting Cox proportional hazards models as well, though I still barely understand them. Any advice on this would be greatly appreciated.&lt;/p&gt;
&lt;p&gt;For general theory on M-estimation, I recommend &lt;span class=&#34;citation&#34;&gt;Stefanski and Boos (&lt;a href=&#34;#ref-stefanskiCalculusMEstimation2002&#34;&gt;2002&lt;/a&gt;)&lt;/span&gt;, and for its application to weighted regression models, I recommend &lt;span class=&#34;citation&#34;&gt;Gabriel et al. (&lt;a href=&#34;#ref-gabrielInverseProbabilityTreatment2024&#34;&gt;2024&lt;/a&gt;)&lt;/span&gt;. I also think looking at the &lt;code&gt;WeightIt&lt;/code&gt; source code can be illuminating; I think I did a good job of keeping it pretty simple and providing example code that anyone could use to program their own M-estimators. It‚Äôs really a lot easier than I thought and I‚Äôm glad I took the time to learn. I know it‚Äôs a fundamental technique for many biostatisticians and econometricians, but I always used to see it as a highly advanced and arcane method that I would never come to understand, until I came to understand it (3.5 years out from my PhD).&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;other-updates&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Other updates&lt;/h2&gt;
&lt;p&gt;There are a few smaller updates to &lt;code&gt;WeightIt&lt;/code&gt; that I would feel bad about omitting.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;First, the package documentation now uses &lt;code&gt;Roxygen&lt;/code&gt;. This doesn‚Äôt affect use but might make it easier for someone reading the source code.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I added a new function, &lt;code&gt;calibrate()&lt;/code&gt;, which calibrates propensity scores using Platt scaling as recommended by &lt;span class=&#34;citation&#34;&gt;Gutman, Karavani, and Shimoni (&lt;a href=&#34;#ref-gutmanPropensityScoreModels2022&#34;&gt;2022&lt;/a&gt;)&lt;/span&gt;. This can slightly improve performance when a machine learning model is used to estimate the propensity score, but is unlikely to be useful otherwise.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A new argument, &lt;code&gt;quantile&lt;/code&gt;, can be supplied to &lt;code&gt;weightit()&lt;/code&gt; for methods that also accept &lt;code&gt;moments&lt;/code&gt; and &lt;code&gt;int&lt;/code&gt; which can be used to balance quantiles of the covariate distribution (e.g., the median, etc.) instead of just the means and means of moments. This is based on &lt;span class=&#34;citation&#34;&gt;Berƒôsewicz (&lt;a href=&#34;#ref-beresewiczSurveyCalibrationCausal2023&#34;&gt;2023&lt;/a&gt;)&lt;/span&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;trim()&lt;/code&gt; now has a &lt;code&gt;drop&lt;/code&gt; argument; setting to &lt;code&gt;TRUE&lt;/code&gt; sets the weights of all trimmed units to 0 (effectively dropping or censroing them). Previously you could only ‚Äútruncate‚Äù the weights, i.e., set all weights higher than a given quantile to the weight at that quantile, but weight trimming (dropping units with extreme weights) has an extensive history as well &lt;span class=&#34;citation&#34;&gt;(&lt;a href=&#34;#ref-thoemmesPrimerInverseProbability2016&#34;&gt;Thoemmes and Ong 2016&lt;/a&gt;; &lt;a href=&#34;#ref-crumpDealingLimitedOverlap2009&#34;&gt;Crump et al. 2009&lt;/a&gt;)&lt;/span&gt;. In my opinion, it is always better to change your estimand prospectively (e.g., to the ATO) than to censor units, but the option is available.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;I made a small change to how g-computation is done; following &lt;span class=&#34;citation&#34;&gt;Gabriel et al. (&lt;a href=&#34;#ref-gabrielInverseProbabilityTreatment2024&#34;&gt;2024&lt;/a&gt;)&lt;/span&gt;, I no longer recommend incorporating the weights in the g-computation step beyond including them in the outcome model. An exception is made when targeting an estimand other than the ATT, ATC, or ATE or when using sampling weights. In practice, it will not make a big difference whether the weights are included or not for the ATE (which is the only estimand affected by this change), but this brings recommendations in line with those in the literature and consistent with &lt;code&gt;teffects ipwra&lt;/code&gt; in Stata.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;For multi-category treatments, the default multinomial logistic regression propensity scores (i.e., with &lt;code&gt;method = &#34;glm&#34;&lt;/code&gt;) require no dependencies. Other ways of estimating the propensity scores are possibly by specifying the &lt;code&gt;multi.method&lt;/code&gt; argument.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;closing-thoughts&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Closing Thoughts&lt;/h2&gt;
&lt;p&gt;Thank you so much for reading and checking out &lt;code&gt;WeightIt&lt;/code&gt;! I hope these new features improve your research or lead to new discoveries. Please let me know if any of my packages have helped you in your work; it makes a big difference to know that my efforts help people.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;references&#34; class=&#34;section level2 unnumbered&#34;&gt;
&lt;h2&gt;References&lt;/h2&gt;
&lt;div id=&#34;refs&#34; class=&#34;references csl-bib-body hanging-indent&#34;&gt;
&lt;div id=&#34;ref-austinBootstrapVsAsymptotic2022&#34; class=&#34;csl-entry&#34;&gt;
Austin, Peter C. 2022. &lt;span&gt;‚ÄúBootstrap Vs Asymptotic Variance Estimation When Using Propensity Score Weighting with Continuous and Binary Outcomes.‚Äù&lt;/span&gt; &lt;em&gt;Statistics in Medicine&lt;/em&gt; 41 (22): 4426‚Äì43. &lt;a href=&#34;https://doi.org/10.1002/sim.9519&#34;&gt;https://doi.org/10.1002/sim.9519&lt;/a&gt;.
&lt;/div&gt;
&lt;div id=&#34;ref-beresewiczSurveyCalibrationCausal2023&#34; class=&#34;csl-entry&#34;&gt;
Berƒôsewicz, Maciej. 2023. &lt;span&gt;‚ÄúSurvey Calibration for Causal Inference: A Simple Method to Balance Covariate Distributions.‚Äù&lt;/span&gt; &lt;a href=&#34;https://doi.org/10.48550/arXiv.2310.11969&#34;&gt;https://doi.org/10.48550/arXiv.2310.11969&lt;/a&gt;.
&lt;/div&gt;
&lt;div id=&#34;ref-chanGloballyEfficientNonparametric2016&#34; class=&#34;csl-entry&#34;&gt;
Chan, Kwun Chuen Gary, Sheung Chi Phillip Yam, and Zheng Zhang. 2016. &lt;span&gt;‚ÄúGlobally Efficient Non-Parametric Inference of Average Treatment Effects by Empirical Balancing Calibration Weighting.‚Äù&lt;/span&gt; &lt;em&gt;Journal of the Royal Statistical Society: Series B (Statistical Methodology)&lt;/em&gt; 78 (3): 673‚Äì700. &lt;a href=&#34;https://doi.org/10.1111/rssb.12129&#34;&gt;https://doi.org/10.1111/rssb.12129&lt;/a&gt;.
&lt;/div&gt;
&lt;div id=&#34;ref-crumpDealingLimitedOverlap2009&#34; class=&#34;csl-entry&#34;&gt;
Crump, R. K., V. J. Hotz, G. W. Imbens, and O. A. Mitnik. 2009. &lt;span&gt;‚ÄúDealing with Limited Overlap in Estimation of Average Treatment Effects.‚Äù&lt;/span&gt; &lt;em&gt;Biometrika&lt;/em&gt; 96 (1): 187‚Äì99. &lt;a href=&#34;https://doi.org/10.1093/biomet/asn055&#34;&gt;https://doi.org/10.1093/biomet/asn055&lt;/a&gt;.
&lt;/div&gt;
&lt;div id=&#34;ref-fongCovariateBalancingPropensity2018&#34; class=&#34;csl-entry&#34;&gt;
Fong, Christian, Chad Hazlett, and Kosuke Imai. 2018. &lt;span&gt;‚ÄúCovariate Balancing Propensity Score for a Continuous Treatment: Application to the Efficacy of Political Advertisements.‚Äù&lt;/span&gt; &lt;em&gt;The Annals of Applied Statistics&lt;/em&gt; 12 (1): 156‚Äì77. &lt;a href=&#34;https://doi.org/10.1214/17-AOAS1101&#34;&gt;https://doi.org/10.1214/17-AOAS1101&lt;/a&gt;.
&lt;/div&gt;
&lt;div id=&#34;ref-gabrielInverseProbabilityTreatment2024&#34; class=&#34;csl-entry&#34;&gt;
Gabriel, Erin E., Michael C. Sachs, Torben Martinussen, Ingeborg Waernbaum, Els Goetghebeur, Stijn Vansteelandt, and Arvid Sj√∂lander. 2024. &lt;span&gt;‚ÄúInverse Probability of Treatment Weighting with Generalized Linear Outcome Models for Doubly Robust Estimation.‚Äù&lt;/span&gt; &lt;em&gt;Statistics in Medicine&lt;/em&gt; 43 (3): 534‚Äì47. &lt;a href=&#34;https://doi.org/10.1002/sim.9969&#34;&gt;https://doi.org/10.1002/sim.9969&lt;/a&gt;.
&lt;/div&gt;
&lt;div id=&#34;ref-grahamInverseProbabilityTilting2012&#34; class=&#34;csl-entry&#34;&gt;
Graham, Bryan S., Cristine Campos De Xavier Pinto, and Daniel Egel. 2012. &lt;span&gt;‚ÄúInverse Probability Tilting for Moment Condition Models with Missing Data.‚Äù&lt;/span&gt; &lt;em&gt;The Review of Economic Studies&lt;/em&gt; 79 (3): 1053‚Äì79. &lt;a href=&#34;https://doi.org/10.1093/restud/rdr047&#34;&gt;https://doi.org/10.1093/restud/rdr047&lt;/a&gt;.
&lt;/div&gt;
&lt;div id=&#34;ref-gutmanPropensityScoreModels2022&#34; class=&#34;csl-entry&#34;&gt;
Gutman, Rom, Ehud Karavani, and Yishai Shimoni. 2022. &lt;span&gt;‚ÄúPropensity Score Models Are Better When Post-Calibrated.‚Äù&lt;/span&gt;
&lt;/div&gt;
&lt;div id=&#34;ref-imai2014&#34; class=&#34;csl-entry&#34;&gt;
Imai, Kosuke, and Marc Ratkovic. 2014. &lt;span&gt;‚ÄúCovariate Balancing Propensity Score.‚Äù&lt;/span&gt; &lt;em&gt;Journal of the Royal Statistical Society: Series B (Statistical Methodology)&lt;/em&gt; 76 (1): 243263. &lt;a href=&#34;https://doi.org/10.1111/rssb.12027&#34;&gt;https://doi.org/10.1111/rssb.12027&lt;/a&gt;.
&lt;/div&gt;
&lt;div id=&#34;ref-imaiRobustEstimationInverse2015&#34; class=&#34;csl-entry&#34;&gt;
‚Äî‚Äî‚Äî. 2015. &lt;span&gt;‚ÄúRobust Estimation of Inverse Probability Weights for Marginal Structural Models.‚Äù&lt;/span&gt; &lt;em&gt;Journal of the American Statistical Association&lt;/em&gt; 110 (511): 1013‚Äì23. &lt;a href=&#34;https://doi.org/10.1080/01621459.2014.956872&#34;&gt;https://doi.org/10.1080/01621459.2014.956872&lt;/a&gt;.
&lt;/div&gt;
&lt;div id=&#34;ref-luncefordStratificationWeightingPropensity2004&#34; class=&#34;csl-entry&#34;&gt;
Lunceford, Jared K., and Marie Davidian. 2004. &lt;span&gt;‚ÄúStratification and Weighting via the Propensity Score in Estimation of Causal Treatment Effects: A Comparative Study.‚Äù&lt;/span&gt; &lt;em&gt;Statistics in Medicine&lt;/em&gt; 23 (19): 29372960. &lt;a href=&#34;https://doi.org/10.1002/sim.1903&#34;&gt;https://doi.org/10.1002/sim.1903&lt;/a&gt;.
&lt;/div&gt;
&lt;div id=&#34;ref-reifeisVarianceTreatmentEffect2022&#34; class=&#34;csl-entry&#34;&gt;
Reifeis, Sarah A, and Michael G Hudgens. 2022. &lt;span&gt;‚ÄúOn Variance of the Treatment Effect in the Treated When Estimated by Inverse Probability Weighting.‚Äù&lt;/span&gt; &lt;em&gt;American Journal of Epidemiology&lt;/em&gt; 191 (6): 1092‚Äì97. &lt;a href=&#34;https://doi.org/10.1093/aje/kwac014&#34;&gt;https://doi.org/10.1093/aje/kwac014&lt;/a&gt;.
&lt;/div&gt;
&lt;div id=&#34;ref-santannaDoublyRobustDifferenceindifferences2020&#34; class=&#34;csl-entry&#34;&gt;
Sant‚ÄôAnna, Pedro H. C., and Jun Zhao. 2020. &lt;span&gt;‚ÄúDoubly Robust Difference-in-Differences Estimators.‚Äù&lt;/span&gt; &lt;em&gt;Journal of Econometrics&lt;/em&gt; 219 (1): 101‚Äì22. &lt;a href=&#34;https://doi.org/10.1016/j.jeconom.2020.06.003&#34;&gt;https://doi.org/10.1016/j.jeconom.2020.06.003&lt;/a&gt;.
&lt;/div&gt;
&lt;div id=&#34;ref-stefanskiCalculusMEstimation2002&#34; class=&#34;csl-entry&#34;&gt;
Stefanski, Leonard A., and Dennis D. Boos. 2002. &lt;span&gt;‚ÄúThe Calculus of m-Estimation.‚Äù&lt;/span&gt; &lt;em&gt;The American Statistician&lt;/em&gt; 56 (1): 29‚Äì38. &lt;a href=&#34;https://doi.org/10.1198/000313002753631330&#34;&gt;https://doi.org/10.1198/000313002753631330&lt;/a&gt;.
&lt;/div&gt;
&lt;div id=&#34;ref-thoemmesPrimerInverseProbability2016&#34; class=&#34;csl-entry&#34;&gt;
Thoemmes, Felix J., and Anthony D. Ong. 2016. &lt;span&gt;‚ÄúA Primer on Inverse Probability of Treatment Weighting and Marginal Structural Models.‚Äù&lt;/span&gt; &lt;em&gt;Emerging Adulthood&lt;/em&gt; 4 (1): 40‚Äì59. &lt;a href=&#34;https://doi.org/10.1177/2167696815621645&#34;&gt;https://doi.org/10.1177/2167696815621645&lt;/a&gt;.
&lt;/div&gt;
&lt;div id=&#34;ref-williamsonVarianceReductionRandomised2014&#34; class=&#34;csl-entry&#34;&gt;
Williamson, Elizabeth J., Andrew B. Forbes, and Ian R. White. 2014. &lt;span&gt;‚ÄúVariance Reduction in Randomised Trials by Inverse Probability Weighting Using the Propensity Score.‚Äù&lt;/span&gt; &lt;em&gt;Statistics in Medicine&lt;/em&gt; 33 (5): 721‚Äì37. &lt;a href=&#34;https://doi.org/10.1002/sim.5991&#34;&gt;https://doi.org/10.1002/sim.5991&lt;/a&gt;.
&lt;/div&gt;
&lt;div id=&#34;ref-xuApplicationsFractionalRandomWeightBootstrap2020a&#34; class=&#34;csl-entry&#34;&gt;
Xu, Li, Chris Gotwalt, Yili Hong, Caleb B. King, and William Q. Meeker. 2020. &lt;span&gt;‚ÄúApplications of the Fractional-Random-Weight Bootstrap.‚Äù&lt;/span&gt; &lt;em&gt;The American Statistician&lt;/em&gt; 74 (4): 345‚Äì58. &lt;a href=&#34;https://doi.org/10.1080/00031305.2020.1731599&#34;&gt;https://doi.org/10.1080/00031305.2020.1731599&lt;/a&gt;.
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Estimating Treatment Effects After Weighting with Multiply Imputed Data</title>
      <link>https://ngreifer.github.io/blog/treatment-effects-mi/</link>
      <pubDate>Fri, 10 Feb 2023 00:00:00 +0000</pubDate>
      <guid>https://ngreifer.github.io/blog/treatment-effects-mi/</guid>
      <description>


&lt;p&gt;Multiply imputed data always makes things a little harder. Essentially, you have to perform each step of the analysis in each imputed dataset and then combine the results together in a special way. For basic regression analysis, the &lt;code&gt;mice&lt;/code&gt; package makes fitting models and combining estimates simple. But when we want to do propensity score matching or weighting before fitting our regression models, and when the quantity we want to estimate is not just a coefficient in a regression model, things get a bit harder.&lt;/p&gt;
&lt;p&gt;For doing matching or weighting in multiply imputed data, the R package &lt;code&gt;{MatchThem}&lt;/code&gt; does the job. It essentially provides wrappers for &lt;code&gt;MatchIt::matchit()&lt;/code&gt; and &lt;code&gt;WeightIt::weightit()&lt;/code&gt; for multiply imputed data. It extends &lt;code&gt;{mice}&lt;/code&gt;‚Äôs functionality for fitting regression models in multiply imputed data by automatically incorporating the matched or weighted structure into the estimation of the outcome models. It uses &lt;code&gt;mice::pool()&lt;/code&gt; to pool estimates across multiply imputed data.&lt;/p&gt;
&lt;p&gt;But for estimating treatment effects, it‚Äôs often not as simple as using a regression coefficient. If we include covariates in our outcome model but want a marginal effect, we need to use an average marginal effects procedure (i.e., g-computation) to compute it within each imputed dataset, and then combine the results afterward. The &lt;code&gt;{marginaleffects}&lt;/code&gt; package provides a wonderful interface for performing g-computation, but for multiply imputed data, it can require some programming by the analyst. In this guide, I‚Äôll show you how to do that programming to combine treatment effect estimates across multiple imputed datasets.&lt;/p&gt;
&lt;p&gt;An alternative to using &lt;code&gt;{marginaleffects}&lt;/code&gt; is to use the &lt;code&gt;{clarify}&lt;/code&gt; package. &lt;code&gt;{clarify}&lt;/code&gt; can also be used to perform g-computation, but it uses simulation-based inference to compute the uncertainty bounds for the estimate. An advantage of simulation-based inference for multiply imputed data is that combining estimates across imputed datasets is much more straightforward. In this guide, I‚Äôll also show you how to use &lt;code&gt;{clarify}&lt;/code&gt; to combine treatment effect estimates across imputed datasets.&lt;/p&gt;
&lt;div id=&#34;packages-well-need&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Packages we‚Äôll need&lt;/h3&gt;
&lt;p&gt;We will need the following packages for this demonstration: &lt;code&gt;cobalt&lt;/code&gt;, &lt;code&gt;mice&lt;/code&gt;, &lt;code&gt;MatchThem&lt;/code&gt;, &lt;code&gt;WeightIt&lt;/code&gt;, &lt;code&gt;marginaleffects&lt;/code&gt;, and &lt;code&gt;clarify&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;the-data&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;The data&lt;/h3&gt;
&lt;p&gt;As usual, we‚Äôll be using a version of the &lt;code&gt;lalonde&lt;/code&gt; dataset. Here will use the &lt;code&gt;lalonde_mis&lt;/code&gt; dataset in &lt;code&gt;{cobalt}&lt;/code&gt;, which has missing values.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;data(&amp;quot;lalonde_mis&amp;quot;, package = &amp;quot;cobalt&amp;quot;)

summary(lalonde_mis)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      treat             age             educ           race        married          nodegree           re74              re75              re78        
##  Min.   :0.0000   Min.   :16.00   Min.   : 0.00   black :243   Min.   :0.0000   Min.   :0.0000   Min.   :    0.0   Min.   :    0.0   Min.   :    0.0  
##  1st Qu.:0.0000   1st Qu.:20.00   1st Qu.: 9.00   hispan: 72   1st Qu.:0.0000   1st Qu.:0.0000   1st Qu.:    0.0   1st Qu.:    0.0   1st Qu.:  238.3  
##  Median :0.0000   Median :25.00   Median :11.00   white :299   Median :0.0000   Median :1.0000   Median :  984.5   Median :  585.4   Median : 4759.0  
##  Mean   :0.3013   Mean   :27.36   Mean   :10.27                Mean   :0.4158   Mean   :0.6303   Mean   : 4420.2   Mean   : 2170.3   Mean   : 6792.8  
##  3rd Qu.:1.0000   3rd Qu.:32.00   3rd Qu.:12.00                3rd Qu.:1.0000   3rd Qu.:1.0000   3rd Qu.: 7626.9   3rd Qu.: 3202.0   3rd Qu.:10893.6  
##  Max.   :1.0000   Max.   :55.00   Max.   :18.00                Max.   :1.0000   Max.   :1.0000   Max.   :35040.1   Max.   :25142.2   Max.   :60307.9  
##                                                                NA&amp;#39;s   :20                        NA&amp;#39;s   :40        NA&amp;#39;s   :39&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can see there are some missing values in &lt;code&gt;married&lt;/code&gt;, &lt;code&gt;re74&lt;/code&gt;, and &lt;code&gt;re75&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;imputing-the-data&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Imputing the data&lt;/h3&gt;
&lt;p&gt;Here, we‚Äôll use &lt;code&gt;{mice}&lt;/code&gt; to impute the data. Although typically something like 20 imputation is sufficient, for the method &lt;code&gt;{clarify}&lt;/code&gt; uses, it needs way more, so we‚Äôll use 50. We‚Äôll use the default settings, but you should tailor the imputation to fit the needs of your dataset. (I always like to use a machine learning method for my imputations). We‚Äôll also set a seed to ensure replicability.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(&amp;quot;mice&amp;quot;)
set.seed(12345)
imp &amp;lt;- mice(lalonde_mis, m = 50, printFlag = FALSE)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;mice()&lt;/code&gt; returns a &lt;code&gt;mids&lt;/code&gt; object, which contains the imputed datasets. Although we could extract the datasets using &lt;code&gt;complete()&lt;/code&gt;, we‚Äôll supply this object directly to our function for estimating the propensity score weights.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;weighting-the-imputed-data&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Weighting the imputed data&lt;/h3&gt;
&lt;p&gt;We‚Äôll use &lt;code&gt;MatchThem::weightthem()&lt;/code&gt; to estimate propensity score weights in the imputed datasets. We could also use &lt;code&gt;MatchThem::matchthem()&lt;/code&gt; to do matching; the process is basically identical&lt;a href=&#34;#fn1&#34; class=&#34;footnote-ref&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;. Here we‚Äôll use logistic regression (ü§¢) to estimate ATT weights to keep things quick and simple.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(&amp;quot;MatchThem&amp;quot;)
w.imp &amp;lt;- weightthem(treat ~ age + educ + race + married + nodegree +
                      re74 + re75, data = imp, method = &amp;quot;ps&amp;quot;,
                    estimand = &amp;quot;ATT&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let‚Äôs assess balance using &lt;code&gt;{cobalt}&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(&amp;quot;cobalt&amp;quot;)
bal.tab(w.imp, stats = c(&amp;quot;m&amp;quot;, &amp;quot;ks&amp;quot;), abs = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Balance summary across all imputations
##                 Type Mean.Diff.Adj Max.Diff.Adj Mean.KS.Adj Max.KS.Adj
## prop.score  Distance        0.0235       0.0379      0.1166     0.1327
## age          Contin.        0.1120       0.1343      0.3053     0.3146
## educ         Contin.        0.0352       0.0485      0.0369     0.0412
## race_black    Binary        0.0024       0.0036      0.0024     0.0036
## race_hispan   Binary        0.0003       0.0007      0.0003     0.0007
## race_white    Binary        0.0022       0.0030      0.0022     0.0030
## married       Binary        0.0168       0.0236      0.0168     0.0236
## nodegree      Binary        0.0191       0.0250      0.0191     0.0250
## re74         Contin.        0.0097       0.0281      0.2027     0.2261
## re75         Contin.        0.0075       0.0286      0.1388     0.1648
## 
## Average effective sample sizes across imputations
##                 0   1
## Unadjusted 429.   185
## Adjusted   100.19 185&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Balance could be a bit better on &lt;code&gt;age&lt;/code&gt;, but we‚Äôre going to move on because we have things to do.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;fitting-the-outcome-models&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Fitting the outcome models&lt;/h3&gt;
&lt;p&gt;Our next step is to fit the outcome model in each imputed dataset. Here, our outcome will be &lt;code&gt;re78 == 0&lt;/code&gt;, i.e., whether a unit‚Äôs earnings in 1978 were 0. Ideally, treatment reduces this risk. Although our estimand will be a risk ratio, because we‚Äôre doing g-computation, we can fit a model for the outcome that actually makes sense rather than choosing one based on the convenient interpretation of its coefficients. So, we‚Äôll fit a probit outcome model to really hit home that we need a post-estimation method to estimate our quantity of interest and can‚Äôt rely on our model coefficients.&lt;/p&gt;
&lt;p&gt;Although &lt;code&gt;{MatchThem}&lt;/code&gt; has functionality for fitting models to the imputed datasets that incorporate the weights, for our purposes, it is better to extract the imputed datasets and fit each model manually in a loop. We‚Äôll use &lt;code&gt;glm()&lt;/code&gt; to do so, though the &lt;code&gt;{MatchThem}&lt;/code&gt; and &lt;code&gt;{WeightIt}&lt;/code&gt; documentation may recommend &lt;code&gt;survey::svyglm()&lt;/code&gt; because it correctly computes the robust standard errors. We‚Äôll do that later using &lt;code&gt;{marginaleffects}&lt;/code&gt; and &lt;code&gt;{clarify}&lt;/code&gt; functions so it‚Äôs okay that we don‚Äôt do it now. We‚Äôll use a quasi-binomial model because we have weights.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fits &amp;lt;- lapply(complete(w.imp, &amp;quot;all&amp;quot;), function(d) {
  glm(I(re78 == 0) ~ treat + age + educ + married + race +
        nodegree + re74 + re75, data = d,
      weights = weights, family = quasibinomial(&amp;quot;probit&amp;quot;))
})&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we wanted to interpret the pooled coefficients from our outcome model (and we had included correct estimation of the standard errors, which we didn‚Äôt here), we could use &lt;code&gt;pool(fits) |&amp;gt; summary()&lt;/code&gt; to get them. But none of that is true here so we‚Äôll move on and save the pooling till after we estimate the quantity of interest.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;the-marginaleffects-workflow&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;The &lt;code&gt;{marginaleffects}&lt;/code&gt; workflow&lt;/h2&gt;
&lt;p&gt;Now we have our list of models. Our next step is to estimate the ATT risk ratio in each one (with the correct standard error) and pool the results. If the only quantity we want is the treatment effect, this is easy. We can use &lt;code&gt;marginaleffects::avg_comparisons()&lt;/code&gt; on each model and then use &lt;code&gt;mice::pool()&lt;/code&gt; to pool the results. In our call to &lt;code&gt;avg_comparisons()&lt;/code&gt;, we need to subset the data used to fit each model to just the treated units and supply this to &lt;code&gt;newdata&lt;/code&gt;, supply the name of the variable containing the weights to &lt;code&gt;wts&lt;/code&gt;&lt;a href=&#34;#fn2&#34; class=&#34;footnote-ref&#34; id=&#34;fnref2&#34;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;, supply the robust standard error type (HC3) to &lt;code&gt;vcov&lt;/code&gt;, and specify that we want the log risk ratio of the average estimated potential outcomes by supplying &lt;code&gt;&#34;lnratioavg&#34;&lt;/code&gt; to &lt;code&gt;transform_pre&lt;/code&gt;&lt;a href=&#34;#fn3&#34; class=&#34;footnote-ref&#34; id=&#34;fnref3&#34;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(&amp;quot;marginaleffects&amp;quot;)
comp.imp &amp;lt;- lapply(fits, function(fit) {
  avg_comparisons(fit, newdata = subset(fit$data, treat == 1),
                  variables = &amp;quot;treat&amp;quot;, wts = &amp;quot;weights&amp;quot;, vcov = &amp;quot;HC3&amp;quot;,
                  transform_pre = &amp;quot;lnratioavg&amp;quot;)
})

pooled.comp &amp;lt;- mice::pool(comp.imp)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, we can use &lt;code&gt;summary()&lt;/code&gt; on the resulting object, adding the arguments &lt;code&gt;conf.int = TRUE&lt;/code&gt; to request confidence intervals and &lt;code&gt;exponentiate = TRUE&lt;/code&gt; to get the risk ratio from the log risk ratio.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summary(pooled.comp, conf.int = TRUE,
        exponentiate = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    term              contrast  estimate std.error  statistic       df  p.value    2.5 %   97.5 %
## 1 treat ln(mean(1) / mean(0)) 0.9321569 0.2097534 -0.3349366 610.5055 0.737788 0.617436 1.407298&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We find a risk ratio of approximately 0.932, 95% CI: [0.617, 1.407], indicating that in our sample, the risk of having zero earnings in 1978 decreased slightly for those who received treatment, but we don‚Äôt have strong evidence for such an effect in the population.&lt;/p&gt;
&lt;p&gt;Although this is nice and simple, things get a bit more complicated when we want to estimate multiple comparisons at the same time, estimate the marginal risks, or perform a more complex analysis. Additional programming is required to make &lt;code&gt;mice::pool()&lt;/code&gt; compatible with these more complex quantities. We‚Äôll demonstrate how to hack &lt;code&gt;{marginaleffects}&lt;/code&gt; to make it work using the instructions in the &lt;code&gt;{marginaleffects}&lt;/code&gt; &lt;a href=&#34;https://vincentarelbundock.github.io/marginaleffects/articles/multiple_imputation.html&#34;&gt;vignette on multiple imputation&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;We‚Äôll be using &lt;code&gt;avg_predictions()&lt;/code&gt; on each model to compute the marginal risks under each treatment level, which uses a similar syntax to &lt;code&gt;comparisons()&lt;/code&gt;. The challenge comes in that &lt;code&gt;avg_predictions()&lt;/code&gt; produces two rows of output (one for each treatment level), which are not correctly distinguished by &lt;code&gt;mice::pool()&lt;/code&gt;. So, we‚Äôll have to create a new custom class and write a new &lt;code&gt;tidy()&lt;/code&gt; method for our class.&lt;/p&gt;
&lt;p&gt;First, we‚Äôll generate our marginal risks and assign the output our new class, which is arbitrary but which I will call &lt;code&gt;&#34;pred_imp_custom&#34;&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;pred.imp &amp;lt;- lapply(fits, function(fit) {
  out &amp;lt;- avg_predictions(fit, newdata = subset(fit$data, treat == 1),
                         variables = &amp;quot;treat&amp;quot;, wts = &amp;quot;weights&amp;quot;,
                         vcov = &amp;quot;HC3&amp;quot;, by = &amp;quot;treat&amp;quot;)
  
  # the next line assigns our custom class
  class(out) &amp;lt;- c(&amp;quot;pred_imp_custom&amp;quot;, class(out))
  return(out)
})&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next, we‚Äôll write our new &lt;code&gt;tidy()&lt;/code&gt; method. (Make sure to replace &lt;code&gt;treat&lt;/code&gt; everywhere you see it with the name of your treatment variable.) We won‚Äôt actually be using this function at all; it is called internally by &lt;code&gt;mice::pool()&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;tidy.pred_imp_custom &amp;lt;- function(x, ...) {
    out &amp;lt;- marginaleffects:::tidy.predictions(x, ...)
    out$term &amp;lt;- paste(&amp;quot;treat =&amp;quot;, out$treat)
    return(out)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, we can use &lt;code&gt;mice::pool()&lt;/code&gt; and &lt;code&gt;summary()&lt;/code&gt; to get our marginal risks:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;mice::pool(pred.imp) |&amp;gt; summary(conf.int = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##        term  estimate  std.error statistic       df      p.value     2.5 %    97.5 %
## 1 treat = 0 0.2607090 0.04264062  6.114100 609.4350 1.734761e-09 0.1769686 0.3444494
## 2 treat = 1 0.2430092 0.03197686  7.599534 611.9484 1.120645e-13 0.1802115 0.3058069&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Taking the ratio of these risks gives us the risk ratio we computed above.&lt;/p&gt;
&lt;p&gt;Note that you have to customize the &lt;code&gt;tidy()&lt;/code&gt; method in a slightly different way when you are estimating treatment effects in subgroups. I‚Äôll leave that as an exercise to the reader, or you can hire me to do it for you :)&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;the-clarify-workflow&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;The &lt;code&gt;{clarify}&lt;/code&gt; workflow&lt;/h2&gt;
&lt;p&gt;The &lt;code&gt;{clarify}&lt;/code&gt; workflow for multiply imputed data is very similar to its workflow for regular data. How simulation-based inference works broadly is that sets of parameters are drawn from a distribution after fitting the model; this distribution is often assumed to be multivariate normal with the mean vector equal to the estimated coefficients and the covariance equal to the asymptotic covariance matrix of the coefficients. Many (e.g., 1000) sets of coefficients are drawn, and a quantity of interest is computed using each set, forming a ‚Äúposterior‚Äù distribution of the quantity of interest. This posterior is then used for inference: its standard deviation can be used as the quantity‚Äôs standard error, and its quantiles can be used as confidence intervals. For more information on this methodology, see the &lt;code&gt;{clarify}&lt;/code&gt; &lt;a href=&#34;https://iqss.github.io/clarify/&#34;&gt;website&lt;/a&gt; and its references.&lt;/p&gt;
&lt;p&gt;With multiply imputed data, this process is done for the model fit to each imputed dataset, and then the distributions of the quantities of interest are simply combined to form a single distribution, which is used for inference. In Bayesian terms, this would be called ‚Äúmixing draws‚Äù. The variance of this mixture distribution approaches the variance of the estimate computed using Rubin‚Äôs rules when the number of imputations is high.&lt;/p&gt;
&lt;p&gt;To use &lt;code&gt;{clarify}&lt;/code&gt;, we supply the list of fitted models to &lt;code&gt;clarify::misim()&lt;/code&gt;, which draws the coefficients from their implied distributions from each model. We also need to specify the method for computing the covariance matrix (here, using the same HC3 robust covariance we used with &lt;code&gt;{marginaleffects}&lt;/code&gt; to account for the weights). We will only request 200 replications per fitted model since we have 50 imputations, which gives us 10,000 replicates (likely more than enough for stable inference).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(&amp;quot;clarify&amp;quot;)

sim.imp &amp;lt;- misim(fits, n = 200, vcov = &amp;quot;HC3&amp;quot;)
sim.imp&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## A `clarify_misim` object
##  - 10 coefficients, 50 imputations with 200 simulated values each
##  - sampled distributions: multivariate t(604)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(Note: because we used a quasi-binomial model, a scaled t-distribution was used to draw the coefficients. In practice this will give similar draws to a normal distribution.)&lt;/p&gt;
&lt;p&gt;The output of &lt;code&gt;misim()&lt;/code&gt; is then fed to a function for computing the quantity of interest in each draw; here, we‚Äôll be using &lt;code&gt;clarify::sim_ame()&lt;/code&gt;, which is appropriate for computing marginal risks in a subset of the data (i.e., the ATT risk ratio). We supply the treatment variable to &lt;code&gt;var&lt;/code&gt; and subset the data to just the treated units using &lt;code&gt;subset&lt;/code&gt; to request the ATT. Although we can use the &lt;code&gt;contrast&lt;/code&gt; argument to request the (log) risk ratio, we can compute that afterward quickly from the marginal risks. (Using &lt;code&gt;cl = 3&lt;/code&gt; uses parallel computing with 3 cores but only if you are on a Mac. See the &lt;code&gt;sim_ame()&lt;/code&gt; documentation for more information on how to use the &lt;code&gt;cl&lt;/code&gt; argument.)&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sim.att &amp;lt;- sim_ame(sim.imp, var = &amp;quot;treat&amp;quot;,
                   subset = treat == 1, cl = 3,
                   verbose = FALSE)
sim.att&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## A `clarify_est` object (from `sim_ame()`)
##  - Average marginal effect of `treat`
##  - 10000 simulated values
##  - 2 quantities estimated:                  
##  E[Y(0)] 0.2605322
##  E[Y(1)] 0.2428401&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To compute the risk ratio, we can use &lt;code&gt;transform()&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sim.att &amp;lt;- transform(sim.att, RR = `E[Y(1)]`/`E[Y(0)]`)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, we can compute out confidence intervals and p-values around the estimated marginal risks and risk ratio using &lt;code&gt;summary()&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summary(sim.att, null = c(RR = 1))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##         Estimate 2.5 % 97.5 % P-value
## E[Y(0)]    0.261 0.187  0.354       .
## E[Y(1)]    0.243 0.188  0.313       .
## RR         0.932 0.630  1.421    0.76&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, we find a risk ratio of approximately 0.932, 95% CI: [0.63, 1.421]. The estimates, confidence intervals, and p-values we get from the two methods line up well.&lt;/p&gt;
&lt;p&gt;By default, &lt;code&gt;{clarify}&lt;/code&gt; uses quantile-based confidence intervals and computes the p-values by inverting them (i.e., finding the largest confidence level that yields an interval that excludes the null value and computing the p-value as one minus that level). Wald confidence intervals and p-values can also be request by setting &lt;code&gt;method = &#34;wald&#34;&lt;/code&gt; in the call to &lt;code&gt;summary()&lt;/code&gt;, but these are only recommended if the quantity has a normal distribution (which the risk ratio does not).&lt;/p&gt;
&lt;div id=&#34;explaining-differences-between-the-approaches&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Explaining differences between the approaches&lt;/h3&gt;
&lt;p&gt;Both the delta method- and simulation-based inference approaches are valid, but sometimes you will get results that disagree. The estimates of the quantities of interest may disagree because of how &lt;code&gt;mice::pool()&lt;/code&gt; and &lt;code&gt;clarify::sim_ame()&lt;/code&gt; combine estimates across imputations.&lt;/p&gt;
&lt;p&gt;Rubin‚Äôs rules involve simply taking the mean of the estimates across imputations. This works well when the quantity is collapsible, linear, or has a symmetric (ideally normal) distribution. If the quantity of interest is none of those but can be transformed from a quantity that does have those properties, Rubin‚Äôs rules can be apply to this intermediate quantity before transforming the estimate to get the final results. This is exactly what we did in the &lt;code&gt;{marginaleffects}&lt;/code&gt; workflow when we computed the log risk ratio before pooling and then exponentiating the pooled log risk ratio to arrive at the risk ratio. If we had gone straight into pooling the risk ratio, the resulting estimate might not have been consistent.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;{clarify}&lt;/code&gt; works by first using Rubin‚Äôs pooling rules on the model coefficients, which we assume to be normally distributed, and then computing the quantity of interest in each imputed dataset using draws from the pooled coefficients. A benefit of this strategy is that we don‚Äôt have to wonder whether the quantity of interest satisfies the above properties. The resulting estimates will be consistent because no pooling is done on them; the pooling happens only in the first step.&lt;/p&gt;
&lt;p&gt;Confidence intervals may differ slightly between the two methods, and this could be due to two reasons: 1) the delta method and simulation-based inferences naturally compute confidence intervals in different ways, with the delta method using a first-order Taylor series approximation and assuming normality of the quantity of interest, and simulation-based inference using simulation to generate a ‚Äúposterior‚Äù for the quantity of interest and using its quantiles as the interval; and 2) simulation-based inference requires many imputations for the variance of the posterior to equal the variance of the Rubin‚Äôs rules pooled estimate. More imputations is always better for both methods, so do as many as you can.&lt;/p&gt;
&lt;p&gt;How should you choose between the delta method and simulation-based inference? Use whichever will get you published, of course! (Just kidding.) Use the one you find most trustworthy, that your audience will find the most trustworthy, and that balances the assumptions you are willing to make with the desired precision of the estimate. You might also use the one that seems more natural to you, either conceptually or in terms of usability. Frankly, I find &lt;code&gt;{clarify}&lt;/code&gt; to be easier to use when the quantity of interest is more complicated than a single comparison (e.g., for subgroup analysis or for computing average marginal risks), but &lt;code&gt;{marginaleffects}&lt;/code&gt; can be faster, doesn‚Äôt rely on a stochastic process, and is better-backed by statistical theory. Confirming you get similar results with both methods is always a good idea, and the plotting diagnostics in &lt;code&gt;{clarify}&lt;/code&gt; can be used to determine whether any difference might be due to the failure of the delta method due to violation of one of its assumptions.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes footnotes-end-of-document&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;The key differences is that pair membership needs to be accounted for in estimation of the variance of the outcome model coefficients; this is usually as simply as specifying &lt;code&gt;vcov = ~subclass&lt;/code&gt; to functions in &lt;code&gt;{marginaleffects}&lt;/code&gt; or &lt;code&gt;{clarify}&lt;/code&gt;.&lt;a href=&#34;#fnref1&#34; class=&#34;footnote-back&#34;&gt;‚Ü©Ô∏é&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn2&#34;&gt;&lt;p&gt;This actually isn‚Äôt necessary for the ATT but it‚Äôs walys good practice.&lt;a href=&#34;#fnref2&#34; class=&#34;footnote-back&#34;&gt;‚Ü©Ô∏é&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn3&#34;&gt;&lt;p&gt;Note: we need the log risk ratio because Rubin‚Äôs pooling rules don‚Äôt apply to the risk ratio but do to the log risk ratio. We will exponentiate the log risk ratio and its confidence interval after pooling.&lt;a href=&#34;#fnref3&#34; class=&#34;footnote-back&#34;&gt;‚Ü©Ô∏é&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Genetic Matching, from the Ground Up</title>
      <link>https://ngreifer.github.io/blog/genetic-matching/</link>
      <pubDate>Sat, 08 Oct 2022 00:00:00 +0000</pubDate>
      <guid>https://ngreifer.github.io/blog/genetic-matching/</guid>
      <description>


&lt;p&gt;Genetic matching sounds cool and science-y, something we social scientists love because nobody thinks what we do is ‚Äúreal‚Äù science. And genetic matching is cool and science-y, but not because it has anything to do with genes or DNA. Genetic matching is a method of adjusting for confounding in observational studies; it is a close relative of propensity score matching and Mahalanobis distance matching and serves exactly the same purpose. &lt;span class=&#34;citation&#34;&gt;Sekhon (&lt;a href=&#34;#ref-sekhonMultivariatePropensityScore2011&#34; role=&#34;doc-biblioref&#34;&gt;2011&lt;/a&gt;)&lt;/span&gt; and &lt;span class=&#34;citation&#34;&gt;Diamond and Sekhon (&lt;a href=&#34;#ref-diamondGeneticMatchingEstimating2013&#34; role=&#34;doc-biblioref&#34;&gt;2013&lt;/a&gt;)&lt;/span&gt; describe genetic matching, but I‚Äôll explain it here in simple terms and with an emphasis on its generality, which is undersold by its implementations.&lt;/p&gt;
&lt;p&gt;This post won‚Äôt make any sense if you don‚Äôt know what matching in general is. Go read &lt;span class=&#34;citation&#34;&gt;Stuart (&lt;a href=&#34;#ref-stuartMatchingMethodsCausal2010&#34; role=&#34;doc-biblioref&#34;&gt;2010&lt;/a&gt;)&lt;/span&gt;, &lt;span class=&#34;citation&#34;&gt;Greifer and Stuart (&lt;a href=&#34;#ref-greiferMatchingMethodsConfounder2021a&#34; role=&#34;doc-biblioref&#34;&gt;2021&lt;/a&gt;)&lt;/span&gt;, and the &lt;code&gt;MatchIt&lt;/code&gt; &lt;a href=&#34;https://kosukeimai.github.io/MatchIt/articles/matching-methods.html&#34;&gt;vignette&lt;/a&gt; on matching methods to learn about them. The focus here will be on &lt;em&gt;pair matching&lt;/em&gt;, which involves assigning units to pairs or strata based on the distances between them, then discarding unpaired units.&lt;/p&gt;
&lt;p&gt;The goal of matching is balanced samples, i.e., samples where the distribution of covariates in the treated and control groups is the same so that an estimated treatment effect cannot be said to be due to differences in the covariate distributions. Why, then, do we make pairs? Close pairs create balance, in theory. How do we compute how close units are to each other? There are several ways; a common one is the Mahalanobis distance, as described for matching in &lt;span class=&#34;citation&#34;&gt;Rubin (&lt;a href=&#34;#ref-rubinBiasReductionUsing1980&#34; role=&#34;doc-biblioref&#34;&gt;1980&lt;/a&gt;)&lt;/span&gt;, and which I‚Äôll describe here.&lt;/p&gt;
&lt;p&gt;The &lt;strong&gt;Mahalanobis distance&lt;/strong&gt; between two units &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(j\)&lt;/span&gt; is defined as&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\delta^{md}_{i,j}=\sqrt{(\mathbf{x}_i-\mathbf{x}_j)\Sigma^{-1}(\mathbf{x}_i-\mathbf{x}_j)&amp;#39;}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;where &lt;span class=&#34;math inline&#34;&gt;\(\mathbf{x}_i\)&lt;/span&gt; is the vector of covariates for unit &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; (i.e., that unit‚Äôs row in the dataset) and &lt;span class=&#34;math inline&#34;&gt;\(\Sigma\)&lt;/span&gt; is the covariance matrix of the covariates&lt;a href=&#34;#fn1&#34; class=&#34;footnote-ref&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;. Equivalently, the Mahalanobis distance is the Euclidean distance (i.e., the regular distance) computed on the standardized principal components. The Mahalanobis distance is an improvement over the Euclidean distance of the covariates because it standardizes the covariates to be on the same scale and adjusts for correlations between covariates (so two highly correlated variables only count once). A great description of the Mahalanobis distance is &lt;a href=&#34;https://stats.stackexchange.com/a/62147/116195&#34;&gt;here&lt;/a&gt; (though there it is not described in the context of matching).&lt;/p&gt;
&lt;p&gt;Genetic matching concerns a generalization of the Mahalanobis distance, called the &lt;strong&gt;generalized Mahalanobis distance&lt;/strong&gt;, which additionally involves a weight matrix. The generalized Mahalanobis distance is defined as&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\delta^{gmd}_{i,j}(W)=\sqrt{(\mathbf{x}_i-\mathbf{x}_j)&amp;#39;\left(\Sigma^{-\frac{1}{2}}\right)&amp;#39; W\Sigma^{-\frac{1}{2}}(\mathbf{x}_i-\mathbf{x}_j)}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;where &lt;span class=&#34;math inline&#34;&gt;\(\Sigma^{-\frac{1}{2}}\)&lt;/span&gt; is the ‚Äúsquare root‚Äù of the inverse of the covariance matrix (e.g., the Cholesky decomposition), and &lt;span class=&#34;math inline&#34;&gt;\(W\)&lt;/span&gt; is a symmetric weight matrix that can contain anything but in most cases is a diagonal matrix with a scalar weight for each covariate in &lt;span class=&#34;math inline&#34;&gt;\(\mathbf{x}\)&lt;/span&gt; (not weights for each unit like in propensity score weighting; a weight for each &lt;em&gt;covariate&lt;/em&gt;), i.e., &lt;span class=&#34;math inline&#34;&gt;\(W = \text{diag}(\begin{bmatrix} w_1 &amp;amp; \dots &amp;amp; w_p \end{bmatrix})\)&lt;/span&gt;. The generalized Mahalanobis distance is equal to the usual Mahalanobis distance when &lt;span class=&#34;math inline&#34;&gt;\(W=I\)&lt;/span&gt;, the identity matrix.&lt;/p&gt;
&lt;p&gt;What does any of this have to do with genetic matching? Well, ‚Äúgenetic matching‚Äù is a bit of a misnomer; it‚Äôs not a matching method. It‚Äôs a method of estimating &lt;span class=&#34;math inline&#34;&gt;\(W\)&lt;/span&gt;. Genetic matching finds the &lt;span class=&#34;math inline&#34;&gt;\(W\)&lt;/span&gt; that, when incorporated in a generalized Mahalanobis distance used to match treated and control units, yields the best balance. Once you have found &lt;span class=&#34;math inline&#34;&gt;\(W\)&lt;/span&gt;, you then do a regular round of matching, and that is your matched sample.&lt;/p&gt;
&lt;p&gt;To put it slightly more formally, consider a function &lt;span class=&#34;math inline&#34;&gt;\(\text{match}(\delta)\)&lt;/span&gt;, which takes in a distance matrix &lt;span class=&#34;math inline&#34;&gt;\(\delta\)&lt;/span&gt; and produces a matched set of treated and control units, characterized by a set of matching weights (e.g., 1 if matched, 0 if unmatched) and pair membership for each unit. Consider a function &lt;span class=&#34;math inline&#34;&gt;\(\text{imbalance}(m)\)&lt;/span&gt;, which takes in the output of a &lt;span class=&#34;math inline&#34;&gt;\(\text{match}(\delta)\)&lt;/span&gt; and returns a scalar imbalance metric (e.g., the largest absolute standardized mean difference among all the covariates). We can then write the genetic matching problem as the following:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\underset{W}{\operatorname{arg\,min}} \, \text{imbalance}(\text{match}(\delta^{gmd}(W)))
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Genetic matching is very general; there are many ways to do the matching (i.e., many ways to specify the &lt;span class=&#34;math inline&#34;&gt;\(\text{match}()\)&lt;/span&gt; function) and many ways to characterize imbalance (i.e., many ways to specify the &lt;span class=&#34;math inline&#34;&gt;\(\text{imbalance}()\)&lt;/span&gt; function) (and even several ways to specific &lt;span class=&#34;math inline&#34;&gt;\(\delta()\)&lt;/span&gt;!). Although nearest neighbor matching is often used for &lt;span class=&#34;math inline&#34;&gt;\(\text{match}()\)&lt;/span&gt;, any matching method that uses a distance matrix could be as well. A specific imbalance measure (which I‚Äôll explain in more detail later) is most often used for &lt;span class=&#34;math inline&#34;&gt;\(\text{imbalance}()\)&lt;/span&gt; because it is the default in the software that implements genetic matching, but any imbalance measure could be used, and there has been research that indicates that alternative measures may work better.&lt;/p&gt;
&lt;p&gt;You may be wondering where the ‚Äúgenetic‚Äù part of ‚Äúgenetic matching‚Äù comes in. ‚ÄúGenetic‚Äù comes from the name of the optimization algorithm that is used to solve the genetic matching problem stated above, which is just called the genetic algorithm. In principle, though, any optimization routine could be used; the genetic algorithm was chosen specifically because it deals well with nonsmooth surfaces, which the objective function above surely is. But other optimization methods that do not rely on derivatives do as well, such as ‚Äúparticle swarm optimization‚Äù (we‚Äôre really doing &lt;em&gt;science&lt;/em&gt; here). I don‚Äôt really understand these methods deeply, but we don‚Äôt have to to understand what genetic matching is doing&lt;a href=&#34;#fn2&#34; class=&#34;footnote-ref&#34; id=&#34;fnref2&#34;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;. In order to understand how to tune the algorithm, though, there are some bits worth knowing about, which I‚Äôll briefly cover in the Implementation section below.&lt;/p&gt;
&lt;div id=&#34;implementation&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Implementation&lt;/h3&gt;
&lt;p&gt;Genetic matching is implemented in the &lt;code&gt;{Matching}&lt;/code&gt; package in R, which performs genetic matching to estimate &lt;span class=&#34;math inline&#34;&gt;\(W\)&lt;/span&gt;, performs nearest neighbor matching using &lt;span class=&#34;math inline&#34;&gt;\(\delta^{gmd}(W)\)&lt;/span&gt; or another distance matrix, and then estimates the treatment effect&lt;a href=&#34;#fn3&#34; class=&#34;footnote-ref&#34; id=&#34;fnref3&#34;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;. The &lt;code&gt;GenMatch()&lt;/code&gt; function estimates &lt;span class=&#34;math inline&#34;&gt;\(W\)&lt;/span&gt;, and the &lt;code&gt;Match()&lt;/code&gt; function does the matching on the resulting output&lt;a href=&#34;#fn4&#34; class=&#34;footnote-ref&#34; id=&#34;fnref4&#34;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;. Genetic matching is also available in &lt;code&gt;{MatchIt}&lt;/code&gt; by setting &lt;code&gt;method = &#34;genetic&#34;&lt;/code&gt; in the call to &lt;code&gt;matchit()&lt;/code&gt;, but it just calls &lt;code&gt;GenMatch()&lt;/code&gt; and &lt;code&gt;Match()&lt;/code&gt; from &lt;code&gt;{Matching}&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GenMatch()&lt;/code&gt; relies on &lt;code&gt;rgenoud::genoud()&lt;/code&gt;, one implementation of the genetic algorithm in R. There are a few tuning parameters worth understanding to use genetic matching to its full potential. The most important one is the population size (i.e., the number of candidates in each generation of the genetic algorithm), controlled by the &lt;code&gt;pop.size&lt;/code&gt; argument. All you need to know is that high values are better and slower. Another one perhaps worth knowing about is the number of generations that have to pass with no improvement in the objective function before the algorithm halts and returns the best candidate it has found, controlled by the &lt;code&gt;wait.generations&lt;/code&gt; argument. Here, too, higher values are better and slower.&lt;/p&gt;
&lt;p&gt;A detail I haven‚Äôt emphasized is that the matching method used to to produce the final matched sample using the estimated &lt;span class=&#34;math inline&#34;&gt;\(W\)&lt;/span&gt; should be the same one used in estimating $W$, because the estimated &lt;span class=&#34;math inline&#34;&gt;\(W\)&lt;/span&gt; are tailored to that matching method (i.e., they only optimize balance when supplied to that &lt;span class=&#34;math inline&#34;&gt;\(\text{match}()\)&lt;/span&gt; function)&lt;a href=&#34;#fn5&#34; class=&#34;footnote-ref&#34; id=&#34;fnref5&#34;&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt;. The matching methods available in &lt;code&gt;{Matching}&lt;/code&gt; are nearest neighbor matching with or without replacement, with or without calipers or exact matching constraints, and with &lt;span class=&#34;math inline&#34;&gt;\(1:1\)&lt;/span&gt; or &lt;span class=&#34;math inline&#34;&gt;\(k:1\)&lt;/span&gt; matching. This is a pretty broad set of matching options, though it is not complete (e.g., optimal and full matching are not available). One thing about genetic matching is that it is &lt;em&gt;slow&lt;/em&gt;, so using a fast matching method is useful for not spending forever to get your matches. &lt;code&gt;{Matching}&lt;/code&gt; uses a fast implementation of nearest neighbor matching programmed in C, which makes it fairly fast, though still quite slow for even moderately sized problems.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;the-imbalance-measure&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;The Imbalance Measure&lt;/h3&gt;
&lt;p&gt;The imbalance measure used in genetic matching is critical to its success as a method. Seeking balance using a poor metric means the resulting matched sample will not be able to reduce bias well, even if the optimal values of &lt;span class=&#34;math inline&#34;&gt;\(W\)&lt;/span&gt; that minimize that imbalance measure have been found. One challenge is that there is no clear best imbalance measure to use. Ideally, it should incorporate balance on all covariates, and not just on their means but on their full distributions, and not just the marginal distributions but the joint distributions. The best imbalance measure depends heavily on the true outcome-generating model, which is inherently unknowable (otherwise we wouldn‚Äôt be doing matching in the first place), though there has been some research into it.&lt;/p&gt;
&lt;p&gt;By default, the imbalance measure &lt;code&gt;GenMatch()&lt;/code&gt; uses is the smallest p-value among the sets of two-sample t-tests and Kolmogorov-Smirnov (KS) tests for each covariate. This is a bit of a strange imbalance measure that doesn‚Äôt really show up anywhere else in the literature. &lt;span class=&#34;citation&#34;&gt;Diamond and Sekhon (&lt;a href=&#34;#ref-diamondGeneticMatchingEstimating2013&#34; role=&#34;doc-biblioref&#34;&gt;2013&lt;/a&gt;)&lt;/span&gt; justify the use of p-values (which are typically disregarded as methods to assess balance) by arguing that here they are simply used to put the mean differences and KS statistic on a uniform scale rather than to be interpreted as p-values to be used in a hypothesis test. However, there has been research into other balance criteria that might perform better. &lt;span class=&#34;citation&#34;&gt;Oyenubi and Wittenberg (&lt;a href=&#34;#ref-oyenubiDoesChoiceBalancemeasure2020&#34; role=&#34;doc-biblioref&#34;&gt;2020&lt;/a&gt;)&lt;/span&gt; find that the largest value of a univariate balance measure called the ‚Äúentropic distance‚Äù, which is a relative of the KS statistic, performs well as an imbalance measure. &lt;span class=&#34;citation&#34;&gt;Zhu, Savage, and Ghosh (&lt;a href=&#34;#ref-zhuKernelBasedMetricBalance2018&#34; role=&#34;doc-biblioref&#34;&gt;2018&lt;/a&gt;)&lt;/span&gt; find that a multivariate imbalance measure called the ‚Äúkernel distance‚Äù does well; this measure takes into account the full, joint covariate distribution, unlike the other methods which do not consider the joint distribution, explaining its effectiveness. I am partial to the energy distance &lt;span class=&#34;citation&#34;&gt;(&lt;a href=&#34;#ref-rizzoEnergyDistance2016&#34; role=&#34;doc-biblioref&#34;&gt;Rizzo and Sz√©kely 2016&lt;/a&gt;; &lt;a href=&#34;#ref-hulingEnergyBalancingCovariate2022&#34; role=&#34;doc-biblioref&#34;&gt;Huling and Mak 2022&lt;/a&gt;)&lt;/span&gt;, which is demonstrated to have nice properties and is easy to explain and calculate. Simple balance measures can be effective as well, though; &lt;span class=&#34;citation&#34;&gt;Oyenubi and Wittenberg (&lt;a href=&#34;#ref-oyenubiDoesChoiceBalancemeasure2020&#34; role=&#34;doc-biblioref&#34;&gt;2020&lt;/a&gt;)&lt;/span&gt; and &lt;span class=&#34;citation&#34;&gt;Stuart, Lee, and Leacy (&lt;a href=&#34;#ref-stuartPrognosticScorebasedBalance2013&#34; role=&#34;doc-biblioref&#34;&gt;2013&lt;/a&gt;)&lt;/span&gt; find that standardized mean differences can be effective in assessing balance, even though they only take into account the covariate means and do not consider the joint distribution of the covariates.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;the-covariates&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;The Covariates&lt;/h3&gt;
&lt;p&gt;The generalized Mahalanobis distance depends on &lt;span class=&#34;math inline&#34;&gt;\(\mathbf{x}\)&lt;/span&gt;‚Äìthe covariates, &lt;span class=&#34;math inline&#34;&gt;\(\Sigma\)&lt;/span&gt;‚Äìthe ‚Äúscaling‚Äù matrix (usually the covariance matrix), and &lt;span class=&#34;math inline&#34;&gt;\(W\)&lt;/span&gt;‚Äìthe weights matrix. These, of course, can all be specified in a variety of ways. &lt;span class=&#34;math inline&#34;&gt;\(\mathbf{x}\)&lt;/span&gt; should contain the covariates one would like balance on, though in principle it doesn‚Äôt have to, as long as those covariates are included in the imbalance measure. For example, one might only include 3 of the most important covariates in the calculation of the distance and weights, but optimize balance on all 10 covariates included in the analysis. &lt;span class=&#34;citation&#34;&gt;Diamond and Sekhon (&lt;a href=&#34;#ref-diamondGeneticMatchingEstimating2013&#34; role=&#34;doc-biblioref&#34;&gt;2013&lt;/a&gt;)&lt;/span&gt; recommend including the propensity score in &lt;span class=&#34;math inline&#34;&gt;\(\mathbf{x}\)&lt;/span&gt;, as close pairs on the propensity score tends to yield well-balanced samples (which is the motivation behind propensity score matching in the first place). On the other hand, &lt;span class=&#34;citation&#34;&gt;King and Nielsen (&lt;a href=&#34;#ref-kingWhyPropensityScores2019&#34; role=&#34;doc-biblioref&#34;&gt;2019&lt;/a&gt;)&lt;/span&gt; recommend against including the propensity score if balance can be achieved without it.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;examples&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Examples&lt;/h2&gt;
&lt;p&gt;Below are some examples of genetic matching. First we‚Äôll use &lt;code&gt;{Matching}&lt;/code&gt;, which gives us a bit more insight into how the process goes, and then we‚Äôll perform the same analysis using &lt;code&gt;{MatchIt}&lt;/code&gt; to demonstrate how much easier it is. We‚Äôll use the &lt;code&gt;lalonde&lt;/code&gt; dataset in &lt;code&gt;{MatchIt}&lt;/code&gt; for this analysis&lt;a href=&#34;#fn6&#34; class=&#34;footnote-ref&#34; id=&#34;fnref6&#34;&gt;&lt;sup&gt;6&lt;/sup&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;div id=&#34;using-matching&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Using &lt;code&gt;Matching&lt;/code&gt;&lt;/h3&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;data(&amp;quot;lalonde&amp;quot;, package = &amp;quot;MatchIt&amp;quot;)

covs &amp;lt;- lalonde |&amp;gt; subset(select = c(age, educ, married,
                                     race, nodegree,
                                     re74, re75))
treat &amp;lt;- lalonde$treat&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We have a factor variable (&lt;code&gt;race&lt;/code&gt;) among our covariates, so we need to turn it into a set of dummy variables for &lt;code&gt;{Matching}&lt;/code&gt; . The &lt;code&gt;{cobalt}&lt;/code&gt; function &lt;code&gt;splitfactor()&lt;/code&gt; makes this easy.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;covs &amp;lt;- covs |&amp;gt; cobalt::splitfactor(drop.first = FALSE)

head(covs)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      age educ married race_black race_hispan race_white nodegree re74 re75
## NSW1  37   11       1          1           0          0        1    0    0
## NSW2  22    9       0          0           1          0        1    0    0
## NSW3  30   12       0          1           0          0        0    0    0
## NSW4  27   11       0          1           0          0        1    0    0
## NSW5  33    8       0          1           0          0        1    0    0
## NSW6  22    9       0          1           0          0        1    0    0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We‚Äôll estimate a propensity score to include among the covariates, as recommended by &lt;span class=&#34;citation&#34;&gt;Diamond and Sekhon (&lt;a href=&#34;#ref-diamondGeneticMatchingEstimating2013&#34; role=&#34;doc-biblioref&#34;&gt;2013&lt;/a&gt;)&lt;/span&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;## Logistic regression PS
ps &amp;lt;- glm(treat ~ age + educ + married + race +
            nodegree + re74 + re75, data = lalonde,
          family = binomial) |&amp;gt;
  fitted()

## Append the PS to the covariates
covs_ps &amp;lt;- cbind(ps, covs)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Okay, now we‚Äôre finally ready to use functions in &lt;code&gt;{Matching}&lt;/code&gt; to perform genetic matching. The first step is to use &lt;code&gt;GenMatch()&lt;/code&gt; to compute &lt;span class=&#34;math inline&#34;&gt;\(W\)&lt;/span&gt;, and after that we will use &lt;code&gt;Match()&lt;/code&gt; to perform the matching using the &lt;code&gt;GenMatch()&lt;/code&gt; output. To use &lt;code&gt;GenMatch()&lt;/code&gt;, we have to know what kind of matching we eventually want to do. In this example, we‚Äôll do 2:1 matching with replacement for the ATT. &lt;code&gt;{Matching}&lt;/code&gt; has a few extra quirks that need to be addressed to make the matching work as intended, which I‚Äôll include in the code below without much explanation (since my recommendation is to use &lt;code&gt;{MatchIt}&lt;/code&gt; anyway, which takes care of these automatically).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(Matching)
# Set seed for reproducibility; genetic matching has a random
# component
set.seed(333)
Gen_out &amp;lt;- GenMatch(
  Tr = treat,             #Treatment
  X = covs_ps,            #Covariates to match on
  BalanceMatrix = covs,   #Covariance to balance
  estimand = &amp;quot;ATT&amp;quot;,       #Estimand
  M = 2,                  #2:1 matching
  replace = TRUE,         #With replacement
  ties = FALSE,           #No ties
  distance.tolerance = 0, #Use precise values
  print.level = 0,        #Don&amp;#39;t print output
  pop.size = 200          #Genetic population size; bigger is better
)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The important part of the &lt;code&gt;GenMatch()&lt;/code&gt; output is the &lt;code&gt;Weight.matrix&lt;/code&gt;, which corresponds to &lt;span class=&#34;math inline&#34;&gt;\(W\)&lt;/span&gt;. It‚Äôs not really worth interpreting the weights; they are just whatever values happened to yield the best balance and don‚Äôt actually tell you anything about how important any covariate is to the treatment. We can supply the weights to the &lt;code&gt;Match()&lt;/code&gt; function to do a final round of matching. All the arguments related to matching (e.g., &lt;code&gt;estimand&lt;/code&gt;, &lt;code&gt;M&lt;/code&gt;, &lt;code&gt;replace&lt;/code&gt;, etc.) should be the same between &lt;code&gt;GenMatch()&lt;/code&gt; and &lt;code&gt;Match()&lt;/code&gt;. We call &lt;code&gt;Match()&lt;/code&gt; below.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;Match_out &amp;lt;- Match(
  Tr = treat,             #Treatment
  X = covs_ps,            #Covariates to match on
  estimand = &amp;quot;ATT&amp;quot;,       #Estimand
  M = 2,                  #2:1 matching
  replace = TRUE,         #With replacement
  ties = FALSE,           #No ties
  distance.tolerance = 0, #Use precise values
  Weight.matrix = Gen_out$Weight.matrix,
  Weight = 3              #Tell Match() we&amp;#39;re using Weight.matrix
)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally we can take a look at the balance using &lt;code&gt;cobalt::bal.tab()&lt;/code&gt;. Here, we check balance not only on the means but also on the KS statistics, since those are part of what is being optimized by the genetic optimization.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cobalt::bal.tab(Match_out, treat ~ age + educ + married + race +
                  nodegree + re74 + re75, data = lalonde,
                stats = c(&amp;quot;m&amp;quot;, &amp;quot;ks&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Balance Measures
##                Type Diff.Adj KS.Adj
## age         Contin.  -0.0178 0.1378
## educ        Contin.   0.0686 0.0459
## married      Binary   0.0000 0.0000
## race_black   Binary   0.0054 0.0054
## race_hispan  Binary   0.0000 0.0000
## race_white   Binary  -0.0054 0.0054
## nodegree     Binary   0.0135 0.0135
## re74        Contin.   0.0305 0.1270
## re75        Contin.   0.0923 0.0919
## 
## Sample sizes
##                      Control Treated
## All                    429.      185
## Matched (ESS)           42.1     185
## Matched (Unweighted)   121.      185
## Unmatched              308.        0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Below we‚Äôll use &lt;code&gt;MatchIt&lt;/code&gt;, which does everything (adjusting the covariate matrix, estimating propensity scores, optimizing &lt;span class=&#34;math inline&#34;&gt;\(W\)&lt;/span&gt;, and matching on the new distance matrix) all at once.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;using-matchit&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Using &lt;code&gt;MatchIt&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;All we need to do is supply the usual arguments to &lt;code&gt;matchit()&lt;/code&gt; and set &lt;code&gt;method = &#34;genetic&#34;&lt;/code&gt;. See the &lt;code&gt;MatchIt&lt;/code&gt; &lt;a href=&#34;https://kosukeimai.github.io/MatchIt/articles/MatchIt.html&#34;&gt;vignettes&lt;/a&gt; for information on the basic use of &lt;code&gt;matchit()&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(888)
matchit_out &amp;lt;- MatchIt::matchit(
  treat ~ age + educ + married + race +
                  nodegree + re74 + re75,
  data = lalonde,
  method = &amp;quot;genetic&amp;quot;,
  estimand = &amp;quot;ATT&amp;quot;,
  ratio = 2,
  replace = TRUE,
  pop.size = 200
)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By default, &lt;code&gt;matchit()&lt;/code&gt; estimates a propensity score using logistic regression and includes it in the matching covariates (but not the covariates on which balance is optimized), just as we did manually using &lt;code&gt;GenMatch()&lt;/code&gt; above. If you want to use difference variables to balance on from those used to match, use the &lt;code&gt;mahvars&lt;/code&gt; argument, which is explained in the documentation for genetic matching (accessible using &lt;code&gt;help(&#34;method_genetic&#34;, package = &#34;MatchIt&#34;)&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;We can assess balance using &lt;code&gt;summary()&lt;/code&gt; or using &lt;code&gt;bal.tab()&lt;/code&gt;. We‚Äôll do the latter below.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cobalt::bal.tab(matchit_out, stats = c(&amp;quot;m&amp;quot;, &amp;quot;ks&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Balance Measures
##                 Type Diff.Adj KS.Adj
## distance    Distance   0.0337 0.1000
## age          Contin.  -0.0238 0.1514
## educ         Contin.   0.0712 0.0324
## married       Binary  -0.0027 0.0027
## race_black    Binary   0.0081 0.0081
## race_hispan   Binary   0.0000 0.0000
## race_white    Binary  -0.0081 0.0081
## nodegree      Binary   0.0054 0.0054
## re74         Contin.   0.0356 0.1514
## re75         Contin.   0.0689 0.0730
## 
## Sample sizes
##                      Control Treated
## All                    429.      185
## Matched (ESS)           45.6     185
## Matched (Unweighted)   123.      185
## Unmatched              306.        0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The results will differ due to slight differences in how the two functions process their inputs.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;programming-genetic-matching-yourself&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Programming Genetic Matching Yourself&lt;/h2&gt;
&lt;p&gt;Perhaps surprisingly, it‚Äôs fairly easy to program genetic matching yourself. You only need the following ingredients:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;A function that creates a distance matrix from a set of weights &lt;span class=&#34;math inline&#34;&gt;\(W\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;A function that performs matching on a given distance matrix&lt;/li&gt;
&lt;li&gt;A function that evaluates balance on a given matched sample&lt;/li&gt;
&lt;li&gt;A function that performs the genetic optimization&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;These are (fairly) easy to come by, and I‚Äôll show you how to write each of them.&lt;/p&gt;
&lt;p&gt;For the first function, we can use &lt;code&gt;MatchIt::mahalanobis_dist()&lt;/code&gt; if we want &lt;span class=&#34;math inline&#34;&gt;\(\Sigma\)&lt;/span&gt; to be the full covariance matrix of the covariates, but it‚Äôs actually quite a bit simpler to use &lt;code&gt;MatchIt::scaled_euclidean_dist()&lt;/code&gt; to just use the variances of the covariates, which is what &lt;code&gt;GenMatch()&lt;/code&gt; (and therefore &lt;code&gt;matchit()&lt;/code&gt;) does anyway. This is because we can supply to &lt;code&gt;scaled_euclidean_dist()&lt;/code&gt; a vector of variances, which we will simply divide by the weights. So, our function for creating the distance matrix given the set of weights will be the following:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;dist_from_W &amp;lt;- function(W, dist_covs) {
  variances &amp;lt;- apply(dist_covs, 2, var)
  MatchIt::scaled_euclidean_dist(data = dist_covs, var = variances / W)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Of course, there are many ways we could make this more efficient. I just want to demonstrate how easy it is to program genetic matching. Programming it &lt;em&gt;well&lt;/em&gt; is another story.&lt;/p&gt;
&lt;p&gt;Next, we need a function that performs matching on covariates given a distance matrix. We could use &lt;code&gt;optmatch::fullmatch()&lt;/code&gt; for full matching, but &lt;code&gt;matchit()&lt;/code&gt; provides a nice, general interface for many matching methods. We can supply the distance matrix to the &lt;code&gt;distance&lt;/code&gt; argument of &lt;code&gt;matchit()&lt;/code&gt;. A function that takes in a distance matrix and returns a &lt;code&gt;matchit&lt;/code&gt; object containing the matched sample and matching weights is the following&lt;a href=&#34;#fn7&#34; class=&#34;footnote-ref&#34; id=&#34;fnref7&#34;&gt;&lt;sup&gt;7&lt;/sup&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;do_matching_with_dist &amp;lt;- function(dist) {
  MatchIt::matchit(treat ~ 1, data = lalonde, distance = dist,
                   method = &amp;quot;nearest&amp;quot;, ratio = 2, replace = TRUE)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next, we need a function that takes in a &lt;code&gt;matchit&lt;/code&gt; object and computes a scalar balance statistic. You can use your favorite balance statistic, but here I‚Äôll use the maximum absolute standardized mean difference (ASMD) of all the covariates in the matched sample&lt;a href=&#34;#fn8&#34; class=&#34;footnote-ref&#34; id=&#34;fnref8&#34;&gt;&lt;sup&gt;8&lt;/sup&gt;&lt;/a&gt;. This measure can be easily computed using &lt;code&gt;cobalt::col_w_smd()&lt;/code&gt;, which takes in a matrix of covariates, a treatment vector, and a weights vector and returns the weighted ASMDs for each covariate. We will allow the set of covariates to be different from those used to compute the distance measure. We implement this below:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;compute_balance &amp;lt;- function(m, bal_covs, treat) {
  weights &amp;lt;- cobalt::get.w(m)
  max(cobalt::col_w_smd(bal_covs, treat, weights,
                        s.d.denom = &amp;quot;treated&amp;quot;,
                        abs = TRUE))
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Okay! We have the key ingredients for our objective function, which takes in a set of covariates weights &lt;span class=&#34;math inline&#34;&gt;\(W\)&lt;/span&gt; and returns a balance statistic that we want to optimize. Let‚Äôs put everything together into a single function:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;objective &amp;lt;- function(W_, dist_covs, bal_covs, treat) {
  W &amp;lt;- exp(c(0, W_))
  
  dist_from_W(W, dist_covs) |&amp;gt;
    do_matching_with_dist() |&amp;gt;
    compute_balance(bal_covs, treat)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first line of the function needs explaining. Instead of optimizing over the weights directly, we‚Äôre going to optimize over the log of the weights. This ensures the weights can prioritize and de-prioritize variables in a symmetric way&lt;a href=&#34;#fn9&#34; class=&#34;footnote-ref&#34; id=&#34;fnref9&#34;&gt;&lt;sup&gt;9&lt;/sup&gt;&lt;/a&gt;. To get back to the weights &lt;code&gt;W&lt;/code&gt; used in the distance measure, we need to exponentiate the optimized log-weights &lt;code&gt;W_&lt;/code&gt;. Also, instead of optimizing over all the weights, we are going to fix one weight to 1 (i.e., fix one log-weight to 0). This is because the matches are invariant to multiplying all the weights by a constant&lt;a href=&#34;#fn10&#34; class=&#34;footnote-ref&#34; id=&#34;fnref10&#34;&gt;&lt;sup&gt;10&lt;/sup&gt;&lt;/a&gt;. So, we can identify the weights by choosing an arbitrary weight to set to 1&lt;a href=&#34;#fn11&#34; class=&#34;footnote-ref&#34; id=&#34;fnref11&#34;&gt;&lt;sup&gt;11&lt;/sup&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;We can give this function a try to see balance when when the log-weights are all set to 0 (i.e., so all weights are equal to 1), which corresponds to matching using the standard scaled Euclidean distance:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;W_test &amp;lt;- rep(0, ncol(covs_ps) - 1)
objective(W_test, dist_covs = covs_ps, bal_covs = covs,
          treat = treat)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.1280539&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we can supply this to a function that performs the genetic algorithm to optimize our objective function. &lt;code&gt;GenMatch()&lt;/code&gt; uses &lt;code&gt;rgenoud::genoud()&lt;/code&gt;, but there is a more modern interface in the R package &lt;code&gt;{GA}&lt;/code&gt;, which we‚Äôll use instead just to demonstrate that the method is software-independent. We‚Äôll use &lt;code&gt;GA::ga()&lt;/code&gt;, which implements the standard genetic algorithm, though other functions are available for more sophisticated methods.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ga()&lt;/code&gt; can only maximize functions, but we want to minimize our imbalance, so we just have to create a new objective function that is the negative of our original.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#Need negative objective to minimize imbalance
neg_objective &amp;lt;- function(...) -objective(...)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Take a look at the &lt;code&gt;GA::ga()&lt;/code&gt; call below. We specify &lt;code&gt;type = &#34;real-valued&#34;&lt;/code&gt; because our weights are real numbers, we supply the negative of our objective function to &lt;code&gt;fitness&lt;/code&gt;, and we supply the additional argument to our functions (&lt;code&gt;dist_covs&lt;/code&gt;, the covariates used in the distance matrix and the weights of which we are optimizing over; &lt;code&gt;bal_covs&lt;/code&gt;, the covariates used to compute the balance statistic that is our criterion; and &lt;code&gt;treat&lt;/code&gt;, the treatment vector). We need to provide lower and upper bounds for the weights, and here I‚Äôve supplied -7 and 7, which correspond to weights of &lt;span class=&#34;math inline&#34;&gt;\(\exp(-7)=.0009\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(\exp(7)=1096.6\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;The next arguments control the speed and performance of the optimization process. I‚Äôve already described &lt;code&gt;popSize&lt;/code&gt;, the population size (called &lt;code&gt;pop.size&lt;/code&gt; in &lt;code&gt;GenMatch()&lt;/code&gt;). We are going to let the algorithm run for 500 generations (&lt;code&gt;maxiter&lt;/code&gt;, called &lt;code&gt;max.generations&lt;/code&gt; in &lt;code&gt;GenMatch()&lt;/code&gt;/&lt;code&gt;genoud()&lt;/code&gt;) but stop if there is no improvement in balance after 100 iterations (&lt;code&gt;run&lt;/code&gt;, called &lt;code&gt;wait.generations&lt;/code&gt; in &lt;code&gt;GenMatch()&lt;/code&gt;/&lt;code&gt;genoud()&lt;/code&gt;). I‚Äôm going to request parallel processing using 4 cores to speed it up, and suppress printing of output&lt;a href=&#34;#fn12&#34; class=&#34;footnote-ref&#34; id=&#34;fnref12&#34;&gt;&lt;sup&gt;12&lt;/sup&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;opt_out &amp;lt;- GA::ga(
  type = &amp;quot;real-valued&amp;quot;,
  fitness = neg_objective,
  dist_covs = covs_ps,
  bal_covs = covs,
  treat = treat,
  lower = rep(-7, ncol(covs_ps) - 1),
  upper = rep(7, ncol(covs_ps) - 1),
  popSize = 200, 
  maxiter = 500,
  run = 100,
  parallel = 4,
  seed = 567, #set seed here if using parallelization
  monitor = NULL
)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This takes my computer about 3 minutes to run. We can run some summaries on the output object to examine the results of the optimization:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summary(opt_out)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## ‚îÄ‚îÄ Genetic Algorithm ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ 
## 
## GA settings: 
## Type                  =  real-valued 
## Population size       =  200 
## Number of generations =  500 
## Elitism               =  10 
## Crossover probability =  0.8 
## Mutation probability  =  0.1 
## Search domain = 
##       x1 x2 x3 x4 x5 x6 x7 x8 x9
## lower -7 -7 -7 -7 -7 -7 -7 -7 -7
## upper  7  7  7  7  7  7  7  7  7
## 
## GA results: 
## Iterations             = 205 
## Fitness function value = -0.02735878 
## Solutions = 
##             x1        x2         x3       x4       x5        x6        x7        x8       x9
## [1,] -2.390895 -3.260254 -0.3561188 1.771811 1.873141 0.4049403 0.5014592 -1.137037 2.931112
## [2,] -2.376927 -3.258679 -0.3536636 1.525004 1.885433 0.3003448 0.5020003 -1.143757 2.929666
## [3,] -2.390895 -3.260254 -0.3561188 1.319585 1.873141 0.4049403 0.5014592 -1.137037 2.931112
## [4,] -2.390895 -3.260254 -0.3561188 1.542400 1.873141 0.4049403 0.5014592 -1.137037 2.931112&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can see that our final value for the criterion was about -0.0274 and this was achieved by each of the sets of log weights displayed. We can just focus on the first row. It‚Äôs not worth over-interpreting these values since their purpose is just to achieve balance and they don‚Äôt reveal anything about the causal or statistical relevance of the covariates. But we can see that &lt;code&gt;x9&lt;/code&gt; (i.e., &lt;code&gt;re75&lt;/code&gt;) was the most important covariate in the distance measure, and &lt;code&gt;x2&lt;/code&gt; (i.e., &lt;code&gt;educ&lt;/code&gt;) was the least important.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;plot(opt_out)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://ngreifer.github.io/blog/genetic-matching/index.en_files/figure-html/unnamed-chunk-17-1.png&#34; width=&#34;576&#34; style=&#34;display: block; margin: auto;&#34; /&gt;
We can also see from the plot that close to the best balance was reached pretty quickly in fewer than 50 generations, and refinements after that were very minor. This suggests that if you‚Äôre in a rush or just want to test out genetic matching without committing to it, you can wait just a few generations (fewer than 100, which is the default in &lt;code&gt;GenMatch()&lt;/code&gt;) to get a good sense of its performance.&lt;/p&gt;
&lt;p&gt;Finally, let‚Äôs perform a final round of matching using the found matching weights and assess balance on each covariate in our matched sample.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#Extract weights by transforming log weights from output
W &amp;lt;- exp(c(0, opt_out@solution[1,]))

#Compute distance measure from weights and do matching
m.out &amp;lt;- dist_from_W(W, covs_ps) |&amp;gt;
  do_matching_with_dist()

m.out&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## A matchit object
##  - method: 2:1 nearest neighbor matching with replacement
##  - distance: User-defined (matrix)
##  - number of obs.: 614 (original), 305 (matched)
##  - target estimand: ATT&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#Assess balance. See ?bal.tab for info on the arguments
cobalt::bal.tab(treat ~ age + educ + married + race +
                  nodegree + re74 + re75,
                data = lalonde, stats = c(&amp;quot;m&amp;quot;, &amp;quot;ks&amp;quot;), 
                binary = &amp;quot;std&amp;quot;, un = TRUE,
                weights = cobalt::get.w(m.out),
                method = &amp;quot;matching&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Balance Measures
##                Type Diff.Un  KS.Un Diff.Adj KS.Adj
## age         Contin. -0.3094 0.1577   0.0249 0.2514
## educ        Contin.  0.0550 0.1114   0.0242 0.0189
## married      Binary -0.8263 0.3236  -0.0207 0.0081
## race_black   Binary  1.7615 0.6404   0.0223 0.0081
## race_hispan  Binary -0.3498 0.0827   0.0000 0.0000
## race_white   Binary -1.8819 0.5577  -0.0274 0.0081
## nodegree     Binary  0.2450 0.1114   0.0238 0.0108
## re74        Contin. -0.7211 0.4470  -0.0270 0.1649
## re75        Contin. -0.2903 0.2876   0.0225 0.0378
## 
## Sample sizes
##                      Control Treated
## All                    429.      185
## Matched (ESS)           51.5     185
## Matched (Unweighted)   120.      185
## Unmatched              309.        0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can see that after matching, the largest standardized mean difference is indeed 0.0274, well below the usual criterion of .1. That doesn‚Äôt mean the sample is fully balanced, though; some KS statistics are a bit high, suggesting that an imbalance measure that accounts for the full distribution of the covariates beyond the means might be more effective. Finally, once satisfactory balance has been found, you can estimate the treatment effect using the methods described in &lt;code&gt;vignette(&#34;estimating-effects&#34;, package = &#34;MatchIt&#34;)&lt;/code&gt;. I‚Äôve gone on long enough so I won‚Äôt do that here.&lt;/p&gt;
&lt;p&gt;Congratulations! You‚Äôve just done genetic matching, three ways!&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;references&#34; class=&#34;section level2 unnumbered&#34;&gt;
&lt;h2&gt;References&lt;/h2&gt;
&lt;div id=&#34;refs&#34; class=&#34;references csl-bib-body hanging-indent&#34;&gt;
&lt;div id=&#34;ref-diamondGeneticMatchingEstimating2013&#34; class=&#34;csl-entry&#34;&gt;
Diamond, Alexis, and Jasjeet S. Sekhon. 2013. &lt;span&gt;‚ÄúGenetic Matching for Estimating Causal Effects: A General Multivariate Matching Method for Achieving Balance in Observational Studies.‚Äù&lt;/span&gt; &lt;em&gt;Review of Economics and Statistics&lt;/em&gt; 95 (3): 932945. &lt;a href=&#34;https://doi.org/10.1162/REST_a_00318&#34;&gt;https://doi.org/10.1162/REST_a_00318&lt;/a&gt;.
&lt;/div&gt;
&lt;div id=&#34;ref-greiferMatchingMethodsConfounder2021a&#34; class=&#34;csl-entry&#34;&gt;
Greifer, Noah, and Elizabeth A Stuart. 2021. &lt;span&gt;‚ÄúMatching Methods for Confounder Adjustment: An Addition to the Epidemiologist&lt;span&gt;‚Äô&lt;/span&gt;s Toolbox.‚Äù&lt;/span&gt; &lt;em&gt;Epidemiologic Reviews&lt;/em&gt;, June, mxab003. &lt;a href=&#34;https://doi.org/10.1093/epirev/mxab003&#34;&gt;https://doi.org/10.1093/epirev/mxab003&lt;/a&gt;.
&lt;/div&gt;
&lt;div id=&#34;ref-hulingEnergyBalancingCovariate2022&#34; class=&#34;csl-entry&#34;&gt;
Huling, Jared D., and Simon Mak. 2022. &lt;span&gt;‚ÄúEnergy &lt;span&gt;Balancing&lt;/span&gt; of &lt;span&gt;Covariate Distributions&lt;/span&gt;.‚Äù&lt;/span&gt; &lt;span&gt;arXiv&lt;/span&gt;. &lt;a href=&#34;https://doi.org/10.48550/arXiv.2004.13962&#34;&gt;https://doi.org/10.48550/arXiv.2004.13962&lt;/a&gt;.
&lt;/div&gt;
&lt;div id=&#34;ref-kingWhyPropensityScores2019&#34; class=&#34;csl-entry&#34;&gt;
King, Gary, and Richard Nielsen. 2019. &lt;span&gt;‚ÄúWhy Propensity Scores Should Not Be Used for Matching.‚Äù&lt;/span&gt; &lt;em&gt;Political Analysis&lt;/em&gt;, May, 1‚Äì20. &lt;a href=&#34;https://doi.org/10.1017/pan.2019.11&#34;&gt;https://doi.org/10.1017/pan.2019.11&lt;/a&gt;.
&lt;/div&gt;
&lt;div id=&#34;ref-oyenubiDoesChoiceBalancemeasure2020&#34; class=&#34;csl-entry&#34;&gt;
Oyenubi, Adeola, and Martin Wittenberg. 2020. &lt;span&gt;‚ÄúDoes the Choice of Balance-Measure Matter Under Genetic Matching?‚Äù&lt;/span&gt; &lt;em&gt;Empirical Economics&lt;/em&gt;, May. &lt;a href=&#34;https://doi.org/10.1007/s00181-020-01873-9&#34;&gt;https://doi.org/10.1007/s00181-020-01873-9&lt;/a&gt;.
&lt;/div&gt;
&lt;div id=&#34;ref-rizzoEnergyDistance2016&#34; class=&#34;csl-entry&#34;&gt;
Rizzo, Maria L., and G√°bor J. Sz√©kely. 2016. &lt;span&gt;‚ÄúEnergy Distance.‚Äù&lt;/span&gt; &lt;em&gt;WIREs Computational Statistics&lt;/em&gt; 8 (1): 27‚Äì38. &lt;a href=&#34;https://doi.org/10.1002/wics.1375&#34;&gt;https://doi.org/10.1002/wics.1375&lt;/a&gt;.
&lt;/div&gt;
&lt;div id=&#34;ref-rubinBiasReductionUsing1980&#34; class=&#34;csl-entry&#34;&gt;
Rubin, Donald B. 1980. &lt;span&gt;‚ÄúBias Reduction Using Mahalanobis-Metric Matching.‚Äù&lt;/span&gt; &lt;em&gt;Biometrics&lt;/em&gt; 36 (2): 293‚Äì98. &lt;a href=&#34;https://doi.org/10.2307/2529981&#34;&gt;https://doi.org/10.2307/2529981&lt;/a&gt;.
&lt;/div&gt;
&lt;div id=&#34;ref-sekhonMultivariatePropensityScore2011&#34; class=&#34;csl-entry&#34;&gt;
Sekhon, Jasjeet S. 2011. &lt;span&gt;‚ÄúMultivariate and Propensity Score Matching Software with Automated Balance Optimization: The Matching Package for R.‚Äù&lt;/span&gt; &lt;em&gt;Journal of Statistical Software&lt;/em&gt; 42 (1): 1‚Äì52. &lt;a href=&#34;https://doi.org/10.18637/jss.v042.i07&#34;&gt;https://doi.org/10.18637/jss.v042.i07&lt;/a&gt;.
&lt;/div&gt;
&lt;div id=&#34;ref-stuartMatchingMethodsCausal2010&#34; class=&#34;csl-entry&#34;&gt;
Stuart, Elizabeth A. 2010. &lt;span&gt;‚ÄúMatching Methods for Causal Inference: A Review and a Look Forward.‚Äù&lt;/span&gt; &lt;em&gt;Statistical Science&lt;/em&gt; 25 (1): 1‚Äì21. &lt;a href=&#34;https://doi.org/10.1214/09-STS313&#34;&gt;https://doi.org/10.1214/09-STS313&lt;/a&gt;.
&lt;/div&gt;
&lt;div id=&#34;ref-stuartPrognosticScorebasedBalance2013&#34; class=&#34;csl-entry&#34;&gt;
Stuart, Elizabeth A., Brian K. Lee, and Finbarr P. Leacy. 2013. &lt;span&gt;‚ÄúPrognostic Score-Based Balance Measures Can Be a Useful Diagnostic for Propensity Score Methods in Comparative Effectiveness Research.‚Äù&lt;/span&gt; &lt;em&gt;Journal of Clinical Epidemiology&lt;/em&gt; 66 (8): S84. &lt;a href=&#34;https://doi.org/10.1016/j.jclinepi.2013.01.013&#34;&gt;https://doi.org/10.1016/j.jclinepi.2013.01.013&lt;/a&gt;.
&lt;/div&gt;
&lt;div id=&#34;ref-zhuKernelBasedMetricBalance2018&#34; class=&#34;csl-entry&#34;&gt;
Zhu, Yeying, Jennifer S. Savage, and Debashis Ghosh. 2018. &lt;span&gt;‚ÄúA Kernel-Based Metric for Balance Assessment.‚Äù&lt;/span&gt; &lt;em&gt;Journal of Causal Inference&lt;/em&gt; 6 (2). &lt;a href=&#34;https://doi.org/10.1515/jci-2016-0029&#34;&gt;https://doi.org/10.1515/jci-2016-0029&lt;/a&gt;.
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes footnotes-end-of-document&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;There are several possible ways to compute &lt;span class=&#34;math inline&#34;&gt;\(\Sigma\)&lt;/span&gt;; for example, &lt;span class=&#34;citation&#34;&gt;Rubin (&lt;a href=&#34;#ref-rubinBiasReductionUsing1980&#34; role=&#34;doc-biblioref&#34;&gt;1980&lt;/a&gt;)&lt;/span&gt; uses the ‚Äúpooled‚Äù covariance matrix, which is a weighted average of the within-group covariances.&lt;a href=&#34;#fnref1&#34; class=&#34;footnote-back&#34;&gt;‚Ü©Ô∏é&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn2&#34;&gt;&lt;p&gt;Basically, they work by proposing a population of guesses of the parameters to be estimated (e.g., 50 sets of candidate &lt;span class=&#34;math inline&#34;&gt;\(W\)&lt;/span&gt;s), removing the candidates with the worst imbalance, and reproducing and perturbing the remaining candidates slightly (like a genetic mutation), then doing this over and over again so that only the best candidates remain. This is a type of ‚Äúevolutionary algorithm‚Äù because it works a bit like natural selection, where the fittest creatures remain to reproduce but with slight variation, and the least fit die off, improving the overall fitness of the species.&lt;a href=&#34;#fnref2&#34; class=&#34;footnote-back&#34;&gt;‚Ü©Ô∏é&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn3&#34;&gt;&lt;p&gt;&lt;code&gt;{Matching}&lt;/code&gt; uses matching imputation to estimate the treatment effect, which is different from running an outcome regression in the matched sample. See my answer &lt;a href=&#34;https://stats.stackexchange.com/a/566981/116195&#34;&gt;here&lt;/a&gt; for some additional details on this distinction and its implications.&lt;a href=&#34;#fnref3&#34; class=&#34;footnote-back&#34;&gt;‚Ü©Ô∏é&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn4&#34;&gt;&lt;p&gt;It‚Äôs maybe worth knowing that &lt;code&gt;GenMatch()&lt;/code&gt; actually uses &lt;span class=&#34;math inline&#34;&gt;\(\Sigma\)&lt;/span&gt; with all the off-diagonal elements set to &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;. This is not described in its documentation or in the papers describing the method. In practice, this likely makes little difference to the overall matching performance. A benefit of this approach is that you get a nice interpretation of the resulting &lt;span class=&#34;math inline&#34;&gt;\(W\)&lt;/span&gt; as importance of each variable in the match, though this interpretation serves little use in practice.&lt;a href=&#34;#fnref4&#34; class=&#34;footnote-back&#34;&gt;‚Ü©Ô∏é&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn5&#34;&gt;&lt;p&gt;Using a different matching method for the final match than you did in estimating &lt;span class=&#34;math inline&#34;&gt;\(W\)&lt;/span&gt; is possible, but not advised.&lt;a href=&#34;#fnref5&#34; class=&#34;footnote-back&#34;&gt;‚Ü©Ô∏é&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn6&#34;&gt;&lt;p&gt;Be careful! There‚Äôs a &lt;code&gt;lalonde&lt;/code&gt; dataset in &lt;code&gt;{Matching}&lt;/code&gt;, too, which is different.&lt;a href=&#34;#fnref6&#34; class=&#34;footnote-back&#34;&gt;‚Ü©Ô∏é&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn7&#34;&gt;&lt;p&gt;Here is seems like we aren‚Äôt matching on any covariates by supplying &lt;code&gt;treat ~ 1&lt;/code&gt; as the model formula; we are supplying the distance matrix ourselves, so the covariates play no role in the matching beyond that. To speed up the evaluation and prevent &lt;code&gt;matchit()&lt;/code&gt; from having to process a whole data frame of covariates, we omit the covariates.&lt;a href=&#34;#fnref7&#34; class=&#34;footnote-back&#34;&gt;‚Ü©Ô∏é&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn8&#34;&gt;&lt;p&gt;This same balance statistic can be used in &lt;code&gt;WeightIt&lt;/code&gt; and &lt;code&gt;twang&lt;/code&gt; for generalized boosted modeling and other methods that involve optimizing a user-supplied criterion.&lt;a href=&#34;#fnref8&#34; class=&#34;footnote-back&#34;&gt;‚Ü©Ô∏é&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn9&#34;&gt;&lt;p&gt;That is, so a weight of 2 is as easy to find as a weight of 1/2, as these have the same ‚Äúmagnitude‚Äù; they correspond to log-weights of .69 and -.69, respectively.&lt;a href=&#34;#fnref9&#34; class=&#34;footnote-back&#34;&gt;‚Ü©Ô∏é&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn10&#34;&gt;&lt;p&gt;That is, the exact same matches found for a given set of weights would be found if all those weights were multiplied by, e.g., 100.&lt;a href=&#34;#fnref10&#34; class=&#34;footnote-back&#34;&gt;‚Ü©Ô∏é&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn11&#34;&gt;&lt;p&gt;It doesn‚Äôt matter which one you choose, but I like to make the propensity score have the scaling weight to assess how much more or less important the covariates are than the propensity score for achieving balance.&lt;a href=&#34;#fnref11&#34; class=&#34;footnote-back&#34;&gt;‚Ü©Ô∏é&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn12&#34;&gt;&lt;p&gt;If you‚Äôre following along at home, try setting &lt;code&gt;monitor = plot&lt;/code&gt; to see a neat plot of the progress of the optimization! We‚Äôll also view this plot after the optimization has finished.&lt;a href=&#34;#fnref12&#34; class=&#34;footnote-back&#34;&gt;‚Ü©Ô∏é&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Subgroup Analysis After Propensity Score Matching Using R</title>
      <link>https://ngreifer.github.io/blog/subgroup-analysis-psm/</link>
      <pubDate>Mon, 05 Sep 2022 00:00:00 +0000</pubDate>
      <guid>https://ngreifer.github.io/blog/subgroup-analysis-psm/</guid>
      <description>


&lt;p&gt;Today I‚Äôm going to demonstrate performing a subgroup analysis after propensity score matching using R. Subgroup analysis, also known as moderation analysis or the analysis of effect modification, concerns the estimation of treatment effects within subgroups of a pre-treatment covariate. This post assumes you understand how to do propensity score matching. For a general introduction to propensity score matching, I recommend &lt;span class=&#34;citation&#34;&gt;Austin (&lt;a href=&#34;#ref-austinIntroductionPropensityScore2011&#34; role=&#34;doc-biblioref&#34;&gt;2011&lt;/a&gt;)&lt;/span&gt; and the &lt;code&gt;{MatchIt}&lt;/code&gt; &lt;a href=&#34;https://kosukeimai.github.io/MatchIt/articles/MatchIt.html&#34;&gt;introductory vignette&lt;/a&gt;. If you understand inverse probability weighting but aren‚Äôt too familiar with matching, I recommend my article with Liz Stuart &lt;span class=&#34;citation&#34;&gt;(&lt;a href=&#34;#ref-greiferMatchingMethodsConfounder2021a&#34; role=&#34;doc-biblioref&#34;&gt;Greifer and Stuart 2021&lt;/a&gt;)&lt;/span&gt;. For an introduction to subgroup analysis with propensity scores, you can also check out &lt;span class=&#34;citation&#34;&gt;Green and Stuart (&lt;a href=&#34;#ref-greenExaminingModerationAnalyses2014&#34; role=&#34;doc-biblioref&#34;&gt;2014&lt;/a&gt;)&lt;/span&gt;. Here, I‚Äôll mainly try to get to the point.&lt;/p&gt;
&lt;p&gt;The dataset we‚Äôll use today is the famous Lalonde dataset, investigating the effect of a job training program on earnings. We‚Äôll use the version of this dataset that comes with the &lt;code&gt;{MatchIt}&lt;/code&gt; package.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;data(&amp;quot;lalonde&amp;quot;, package = &amp;quot;MatchIt&amp;quot;)
head(lalonde)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      treat age educ   race married nodegree re74 re75       re78
## NSW1     1  37   11  black       1        1    0    0  9930.0460
## NSW2     1  22    9 hispan       0        1    0    0  3595.8940
## NSW3     1  30   12  black       0        0    0    0 24909.4500
## NSW4     1  27   11  black       0        1    0    0  7506.1460
## NSW5     1  33    8  black       0        1    0    0   289.7899
## NSW6     1  22    9  black       0        1    0    0  4056.4940&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The treatment is &lt;code&gt;treat&lt;/code&gt;, the outcome in the original study was &lt;code&gt;re78&lt;/code&gt; (1978 earnings), and the other variables are pretreatment covariates that we want to adjust for using propensity score matching. In this example, I‚Äôll actually be using a different outcome, &lt;code&gt;re78_0&lt;/code&gt;, which is whether the participant‚Äôs 1978 earnings were equal to 0 or not, because I want to demonstrate the procedure for a binary outcome. So, we hope the treatment effect is negative, i.e., the risk of 0 earnings decreases for those in the treatment.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;lalonde$re78_0 &amp;lt;- as.numeric(lalonde$re78 == 0)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Our moderator will be &lt;code&gt;race&lt;/code&gt;, a 3-category factor variable.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;with(lalonde, table(race))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## race
##  black hispan  white 
##    243     72    299&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Our estimand will be the subgroup-specific and marginal average treatment effect on the treated (ATT), using the risk difference as our effect measure.&lt;/p&gt;
&lt;div id=&#34;packages-youll-need&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Packages You‚Äôll Need&lt;/h3&gt;
&lt;p&gt;We‚Äôll need a few R packages for this analysis. We‚Äôll need &lt;code&gt;{MatchIt}&lt;/code&gt; and &lt;code&gt;{optmatch}&lt;/code&gt; for the matching, &lt;code&gt;{cobalt}&lt;/code&gt; for the balance assessment, &lt;code&gt;{marginaleffects}&lt;/code&gt; for estimating the treatment effects, and &lt;code&gt;{sandwich}&lt;/code&gt; for computing the standard errors. You can install those using the code below:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;install.packages(c(&amp;quot;MatchIt&amp;quot;, &amp;quot;optmatch&amp;quot;, &amp;quot;cobalt&amp;quot;,
                   &amp;quot;marginaleffects&amp;quot;, &amp;quot;sandwich&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let‚Äôs get into it!&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;step-1-subgroup-matching&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Step 1: Subgroup Matching&lt;/h2&gt;
&lt;p&gt;Our first step is to perform the matching. Although there are a few strategies for performing matching for subgroup analysis, in general subgroup-specific matching tends to work best, though it requires a little extra work.&lt;/p&gt;
&lt;p&gt;We‚Äôll do this by splitting the dataset by &lt;code&gt;race&lt;/code&gt; and performing a separate matching analysis within each one.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#Splitting the data
lalonde_b &amp;lt;- subset(lalonde, race == &amp;quot;black&amp;quot;)
lalonde_h &amp;lt;- subset(lalonde, race == &amp;quot;hispan&amp;quot;)
lalonde_w &amp;lt;- subset(lalonde, race == &amp;quot;white&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here we‚Äôll use full matching because 1:1 matching without replacement, the most common (but worst) way to do propensity score matching, doesn‚Äôt work well in this dataset. The process described below works &lt;em&gt;exactly&lt;/em&gt; the same for 1:1 and most other kinds of matching as it does for full matching. We‚Äôll estimate propensity scores in each subgroup, here using probit regression, which happens to yield better balance than logistic regression does.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(&amp;quot;MatchIt&amp;quot;)

#Matching in race == &amp;quot;black&amp;quot;
m.out_b &amp;lt;- matchit(treat ~ age + educ + married + nodegree + re74 + re75,
                   data = lalonde_b, method = &amp;quot;full&amp;quot;, estimand = &amp;quot;ATT&amp;quot;,
                   link = &amp;quot;probit&amp;quot;)

#Matching in race == &amp;quot;hispan&amp;quot;
m.out_h &amp;lt;- matchit(treat ~ age + educ + married + nodegree + re74 + re75,
                   data = lalonde_h, method = &amp;quot;full&amp;quot;, estimand = &amp;quot;ATT&amp;quot;,
                   link = &amp;quot;probit&amp;quot;)

#Matching in race == &amp;quot;black&amp;quot;
m.out_w &amp;lt;- matchit(treat ~ age + educ + married + nodegree + re74 + re75,
                   data = lalonde_w, method = &amp;quot;full&amp;quot;, estimand = &amp;quot;ATT&amp;quot;,
                   link = &amp;quot;probit&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;step-2-assessing-balance-within-subgroups&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Step 2: Assessing Balance within Subgroups&lt;/h2&gt;
&lt;p&gt;We need to assess subgroup balance; we can do that using &lt;code&gt;summary()&lt;/code&gt; on each &lt;code&gt;matchit&lt;/code&gt; object, or we can use functions from &lt;code&gt;{cobalt}&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Below are examples of using &lt;code&gt;summary()&lt;/code&gt; and &lt;code&gt;cobalt::bal.tab()&lt;/code&gt; on one &lt;code&gt;matchit&lt;/code&gt; object at a time&lt;a href=&#34;#fn1&#34; class=&#34;footnote-ref&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;summary(m.out_b)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
## Call:
## matchit(formula = treat ~ age + educ + married + nodegree + re74 + 
##     re75, data = lalonde_b, method = &amp;quot;full&amp;quot;, link = &amp;quot;probit&amp;quot;, 
##     estimand = &amp;quot;ATT&amp;quot;)
## 
## Summary of Balance for All Data:
##          Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean eCDF Max
## distance        0.6587        0.6121          0.4851     0.7278    0.1134   0.1972
## age            25.9808       26.0690         -0.0121     0.4511    0.0902   0.2378
## educ           10.3141       10.0920          0.1079     0.5436    0.0336   0.0807
## married         0.1859        0.2874         -0.2608          .    0.1015   0.1015
## nodegree        0.7244        0.6437          0.1806          .    0.0807   0.0807
## re74         2155.0132     3117.0584         -0.1881     0.9436    0.0890   0.2863
## re75         1490.7221     1834.4220         -0.1043     1.0667    0.0480   0.1441
## 
## Summary of Balance for Matched Data:
##          Means Treated Means Control Std. Mean Diff. Var. Ratio eCDF Mean eCDF Max Std. Pair Dist.
## distance        0.6587        0.6577          0.0096     1.0403    0.0095   0.0705          0.0374
## age            25.9808       27.6538         -0.2292     0.3644    0.1148   0.2073          1.3764
## educ           10.3141       10.1368          0.0861     0.6552    0.0228   0.0684          1.0485
## married         0.1859        0.1822          0.0096          .    0.0037   0.0037          0.6236
## nodegree        0.7244        0.7286         -0.0096          .    0.0043   0.0043          0.7548
## re74         2155.0132     2998.6538         -0.1650     0.7590    0.0513   0.2025          0.7256
## re75         1490.7221     2120.7862         -0.1911     0.8819    0.0798   0.1912          0.8430
## 
## Sample Sizes:
##               Control Treated
## All             87.       156
## Matched (ESS)   36.04     156
## Matched         87.       156
## Unmatched        0.         0
## Discarded        0.         0&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(&amp;quot;cobalt&amp;quot;)
bal.tab(m.out_b, un = TRUE, stats = c(&amp;quot;m&amp;quot;, &amp;quot;ks&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Balance Measures
##              Type Diff.Un  KS.Un Diff.Adj KS.Adj
## distance Distance  0.4851 0.1972   0.0096 0.0705
## age       Contin. -0.0121 0.2378  -0.2292 0.2073
## educ      Contin.  0.1079 0.0807   0.0861 0.0684
## married    Binary -0.1015 0.1015   0.0037 0.0037
## nodegree   Binary  0.0807 0.0807  -0.0043 0.0043
## re74      Contin. -0.1881 0.2863  -0.1650 0.2025
## re75      Contin. -0.1043 0.1441  -0.1911 0.1912
## 
## Sample sizes
##                      Control Treated
## All                    87.       156
## Matched (ESS)          36.04     156
## Matched (Unweighted)   87.       156&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can also get a clearer sense of balance overall using &lt;code&gt;bal.tab()&lt;/code&gt; by directly supplying the matching weights.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#Initialize the weights
fm_weights &amp;lt;- numeric(nrow(lalonde))

#Assign the weights based on the subgroup
fm_weights[lalonde$race == &amp;quot;black&amp;quot;] &amp;lt;- m.out_b$weights
fm_weights[lalonde$race == &amp;quot;hispan&amp;quot;] &amp;lt;- m.out_h$weights
fm_weights[lalonde$race == &amp;quot;white&amp;quot;] &amp;lt;- m.out_w$weights

bal.tab(treat ~ age + educ + married + nodegree + re74 + re75,
        data = lalonde, weights = fm_weights, cluster = &amp;quot;race&amp;quot;,
        stats = c(&amp;quot;m&amp;quot;, &amp;quot;ks&amp;quot;), abs = TRUE, cluster.summary = TRUE)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Balance by cluster
## 
##  - - - Cluster: black - - - 
## Balance Measures
##             Type Diff.Adj KS.Adj
## age      Contin.   0.2292 0.2073
## educ     Contin.   0.0861 0.0684
## married   Binary   0.0037 0.0037
## nodegree  Binary   0.0043 0.0043
## re74     Contin.   0.1650 0.2025
## re75     Contin.   0.1911 0.1912
## 
## Effective sample sizes
##                0   1
## Unadjusted 87.   156
## Adjusted   36.04 156
## 
##  - - - Cluster: hispan - - - 
## Balance Measures
##             Type Diff.Adj KS.Adj
## age      Contin.   0.2298 0.1848
## educ     Contin.   0.2888 0.2762
## married   Binary   0.0604 0.0604
## nodegree  Binary   0.1024 0.1024
## re74     Contin.   0.1323 0.3188
## re75     Contin.   0.1220 0.2351
## 
## Effective sample sizes
##                0  1
## Unadjusted 61.   11
## Adjusted   26.24 11
## 
##  - - - Cluster: white - - - 
## Balance Measures
##             Type Diff.Adj KS.Adj
## age      Contin.   0.4137 0.2126
## educ     Contin.   0.4246 0.1840
## married   Binary   0.0025 0.0025
## nodegree  Binary   0.1653 0.1653
## re74     Contin.   0.2846 0.4165
## re75     Contin.   0.0825 0.1444
## 
## Effective sample sizes
##                 0  1
## Unadjusted 281.   18
## Adjusted    49.49 18
##  - - - - - - - - - - - - - - 
## 
## Balance summary across all clusters
##             Type Mean.Diff.Adj Max.Diff.Adj Mean.KS.Adj Max.KS.Adj
## age      Contin.        0.2909       0.4137      0.2016     0.2126
## educ     Contin.        0.2665       0.4246      0.1762     0.2762
## married   Binary        0.0222       0.0604      0.0222     0.0604
## nodegree  Binary        0.0907       0.1653      0.0907     0.1653
## re74     Contin.        0.1940       0.2846      0.3126     0.4165
## re75     Contin.        0.1319       0.1911      0.1902     0.2351
## 
## Total effective sample sizes across clusters
##                 0   1
## Unadjusted 429.   185
## Adjusted   111.77 185&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Using the &lt;code&gt;cluster&lt;/code&gt; argument produces balance tables in each subgroup and, because we specified &lt;code&gt;cluster.summary = TRUE&lt;/code&gt;, a balance table summarizing across subgroups. To suppress display of the subgroup-specific balance tables (which may be useful if you have many subgroups), you can specify &lt;code&gt;which.cluster = .none&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;To make a plot displaying the balance statistics visually, we can use &lt;code&gt;cobalt::love.plot()&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;love.plot(treat ~ age + educ + married + nodegree + re74 + re75,
        data = lalonde, weights = fm_weights, cluster = &amp;quot;race&amp;quot;,
        stats = c(&amp;quot;m&amp;quot;, &amp;quot;ks&amp;quot;), abs = TRUE,
        which.cluster = .none, agg.fun = &amp;quot;max&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: Standardized mean differences and raw mean differences are present in the same plot. 
## Use the &amp;#39;stars&amp;#39; argument to distinguish between them and appropriately label the x-axis.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://ngreifer.github.io/blog/subgroup-analysis-psm/index.en_files/figure-html/unnamed-chunk-9-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;See the &lt;code&gt;{cobalt}&lt;/code&gt; &lt;a href=&#34;https://ngreifer.github.io/cobalt/articles/cobalt_A4_love.plot.html&#34;&gt;vignette on customizing &lt;code&gt;love.plot()&lt;/code&gt;&lt;/a&gt; to see how to finely control the appearance of the plot.&lt;/p&gt;
&lt;p&gt;From this output, we can see that balance is actually pretty bad; the greatest standardized mean difference (SMD) across subgroups after matching is around .46, which is way too big. In a realistic scenario, we would try different matching methods, maybe resorting to weighting, until we found good balance across the subgroups. In order to validly interpret the subgroup-specific effects and tests for moderation, we need to achieve balance in each subgroup, not just overall. We didn‚Äôt get good balance here, but to stay focused on the rest of the procedure, we‚Äôll move forward as if we did.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;step-3-fitting-the-outcome-model&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Step 3: Fitting the Outcome Model&lt;/h2&gt;
&lt;p&gt;Next, we‚Äôll fit the outcome model. It‚Äôs important to remember that the outcome model is an intermediate step for estimating the treatment effect; no quantity estimated by the model needs to correspond to the treatment effect directly. We‚Äôll be using a marginal effects procedure to estimate the treatment effects in the next section.&lt;/p&gt;
&lt;p&gt;First, we‚Äôll extract the matched datasets from the &lt;code&gt;matchit&lt;/code&gt; objects. We can‚Äôt just use the matching weights we extracted earlier because we also need subclass (i.e., pair) membership. We‚Äôll use &lt;code&gt;match.data()&lt;/code&gt; from &lt;code&gt;{MatchIt}&lt;/code&gt; to extract the matched datasets, which contain the matching weights and subclass membership in the &lt;code&gt;weights&lt;/code&gt; and &lt;code&gt;subclass&lt;/code&gt; columns, respectively, and use &lt;code&gt;rbind()&lt;/code&gt; to bind them into a single combined dataset&lt;a href=&#34;#fn2&#34; class=&#34;footnote-ref&#34; id=&#34;fnref2&#34;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#Extract the matched datasets
matched_data_b &amp;lt;- match.data(m.out_b)
matched_data_h &amp;lt;- match.data(m.out_h)
matched_data_w &amp;lt;- match.data(m.out_w)

#Combine them using rbind()
matched_data &amp;lt;- rbind(matched_data_b,
                      matched_data_h,
                      matched_data_w)

names(matched_data)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;treat&amp;quot;    &amp;quot;age&amp;quot;      &amp;quot;educ&amp;quot;     &amp;quot;race&amp;quot;     &amp;quot;married&amp;quot;  &amp;quot;nodegree&amp;quot; &amp;quot;re74&amp;quot;     &amp;quot;re75&amp;quot;     &amp;quot;re78&amp;quot;     &amp;quot;re78_0&amp;quot;   &amp;quot;distance&amp;quot; &amp;quot;weights&amp;quot;  &amp;quot;subclass&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next, we can fit the outcome model. The choice of which model to fit should depend primarily on the best model for the outcome; because we have a binary outcome, we‚Äôll use logistic regression.&lt;/p&gt;
&lt;p&gt;It‚Äôs usually a good idea to include covariates in the outcome model. It‚Äôs also usually a good idea to allow the treatment to interact with the covariates in the outcome model. It‚Äôs also usually a good idea to fit separate models within each subgroup. Combining this all yields a pretty complicated model, which is why it will be so important to use a marginal effects procedure rather than trying to interpret the model‚Äôs coefficients. Here‚Äôs how we fit this model:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fit &amp;lt;- glm(re78_0 ~ race * (treat * (age + educ + married + nodegree +
                                       re74 + re75)),
           data = matched_data, weights = weights,
           family = &amp;quot;quasibinomial&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We‚Äôre not even going to look at the output of this model, which has 42 parameters. If the model doesn‚Äôt fit with your dataset, you can remove interactions between the treatment and some covariates or remove the covariates altogether.&lt;/p&gt;
&lt;p&gt;For a linear model, you can use &lt;code&gt;lm()&lt;/code&gt; and remove the &lt;code&gt;family&lt;/code&gt; argument. We used &lt;code&gt;family = &#34;quasibinomial&#34;&lt;/code&gt; because we want logistic regression for our binary outcome but we are using the matching weights, which otherwise create a (harmless but annoying) warning when run with &lt;code&gt;family = &#34;binomial&#34;&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;step-4-estimate-the-treatment-effects&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Step 4: Estimate the Treatment Effects&lt;/h2&gt;
&lt;p&gt;Finally, we can estimate the treatment effects. To do so, we‚Äôll use an average marginal effects procedure as implemented in &lt;code&gt;{marginaleffects}&lt;/code&gt;&lt;a href=&#34;#fn3&#34; class=&#34;footnote-ref&#34; id=&#34;fnref3&#34;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;. First, we‚Äôll estimate the average marginal effect overall, averaging across the subgroups. Again, we‚Äôre hoping for a negative treatment effect, which indicates the risk of having zero income decreased among those who received the treatment. Because we are estimating the ATT, we need to subset the data for which the average marginal effects are computed to just the treated units, which we do using the &lt;code&gt;newdata&lt;/code&gt; argument (which can be omitted when the ATE is the target estimand). We also need to supply pair membership to ensure the standard errors are correctly computed, which we do by supplying the &lt;code&gt;subclass&lt;/code&gt; variable containing pair membership to the &lt;code&gt;vcov&lt;/code&gt; argument. In general, we need to supply the weights to the &lt;code&gt;wts&lt;/code&gt; argument of &lt;code&gt;avg_comparisons()&lt;/code&gt; as well (though, in this case, because we are estimating the ATT and all weights are 1 for the treated group, it doesn‚Äôt make a difference).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(&amp;quot;marginaleffects&amp;quot;)

#Estimate the overall ATT
avg_comparisons(fit, variables = &amp;quot;treat&amp;quot;,
                newdata = subset(matched_data, treat == 1),
                vcov = ~subclass, wts = &amp;quot;weights&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##   Term Contrast Estimate Std. Error      z Pr(&amp;gt;|z|)  2.5 % 97.5 %
##  treat    1 - 0  0.03434    0.04405 0.7795  0.43566 -0.052 0.1207
## 
## Prediction type:  response 
## Columns: type, term, contrast, estimate, std.error, statistic, p.value, conf.low, conf.high&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The estimated risk difference is 0.02305 with a high p-value and a confidence interval containing 0, indicating no evidence of an effect overall. (Note: this doesn‚Äôt mean there is no effect! The data are compatible with effects anywhere within the confidence interval, which includes negative and positive effects of a moderate size!)&lt;/p&gt;
&lt;p&gt;New, let‚Äôs estimate the subgroup-specific effects by supplying the subgrouping variable, &lt;code&gt;&#34;race&#34;&lt;/code&gt;, to the &lt;code&gt;by&lt;/code&gt; argument:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;avg_comparisons(fit, variables = &amp;quot;treat&amp;quot;,
                newdata = subset(matched_data, treat == 1),
                vcov = ~subclass, wts = &amp;quot;weights&amp;quot;,
                by = &amp;quot;race&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##   Term          Contrast   race Estimate Std. Error      z  Pr(&amp;gt;|z|)    2.5 %   97.5 %
##  treat mean(1) - mean(0)  black  0.06985    0.05168  1.352 0.1764930 -0.03144  0.17114
##  treat mean(1) - mean(0) hispan -0.18744    0.07293 -2.570 0.0101667 -0.33038 -0.04450
##  treat mean(1) - mean(0)  white -0.13790    0.04886 -2.822 0.0047678 -0.23367 -0.04214
## 
## Prediction type:  response 
## Columns: type, term, contrast, race, estimate, std.error, statistic, p.value, conf.low, conf.high, predicted, predicted_hi, predicted_lo&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here, we see that actually there is evidence of treatment effects within subgroups! In the subgroups &lt;code&gt;hispan&lt;/code&gt; and &lt;code&gt;white&lt;/code&gt;, we see moderately sized negative effects with small p-values and confidence intervals excluding 0, suggesting that there treatment effects in these subgroups.&lt;/p&gt;
&lt;p&gt;We can also test whether the treatment effects differ between groups using the &lt;code&gt;hypothesis&lt;/code&gt; argument of &lt;code&gt;avg_comparisons()&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;avg_comparisons(fit, variables = &amp;quot;treat&amp;quot;,
                newdata = subset(matched_data, treat == 1),
                vcov = ~subclass, wts = &amp;quot;weights&amp;quot;,
                by = &amp;quot;race&amp;quot;, hypothesis = &amp;quot;pairwise&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##                                                                Term Estimate Std. Error       z  Pr(&amp;gt;|z|)    2.5 % 97.5 %
##  (black,treat,mean(1) - mean(0)) - (hispan,treat,mean(1) - mean(0))  0.25729    0.08939  2.8785 0.0039961  0.08210 0.4325
##   (black,treat,mean(1) - mean(0)) - (white,treat,mean(1) - mean(0))  0.20775    0.07112  2.9211 0.0034877  0.06836 0.3471
##  (hispan,treat,mean(1) - mean(0)) - (white,treat,mean(1) - mean(0)) -0.04954    0.08779 -0.5643 0.5725398 -0.22160 0.1225
## 
## Prediction type:  response 
## Columns: type, term, estimate, std.error, statistic, p.value, conf.low, conf.high&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can see evidence that the treatment effect differs between the &lt;code&gt;black&lt;/code&gt; and &lt;code&gt;hispan&lt;/code&gt; groups, and between the &lt;code&gt;black&lt;/code&gt; and &lt;code&gt;white&lt;/code&gt; groups. With many subgroups, it might be useful to adjust your p-values for multiple comparisons, which we can do using &lt;code&gt;p.adjust()&lt;/code&gt;, e.g.,&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p.adjust(comp$p.value, method = &amp;quot;holm&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;if &lt;code&gt;comp&lt;/code&gt; contained the &lt;code&gt;avg_comparisons()&lt;/code&gt; output above.&lt;/p&gt;
&lt;p&gt;Congratulations! You‚Äôve done a subgroup analysis!&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;step-5-reporting-your-results&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Step 5: Reporting Your Results&lt;/h2&gt;
&lt;p&gt;A fair bit needs to be included when reporting your results to ensure your analysis is replicable and can be correctly interpreted by your audience. The key things to report are the following:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The method of estimating the propensity score and performing the matching (noting that these were done within subgroups), including the estimand targeted and whether that estimand was respected by the procedure (using, e.g., a caliper changes the estimand from the one you specify). This should also include the packages used and, even better, the functions used. If you‚Äôre using &lt;code&gt;{MatchIt}&lt;/code&gt;, the documentation should also tell you which papers to cite.&lt;/li&gt;
&lt;li&gt;A quick summary of other methods you might have tried and why you went with the one you went with (i.e., because it yielded better balance, a greater effective sample size, etc.).&lt;/li&gt;
&lt;li&gt;Covariate balance, measured broadly; this can include a balance table, a balance plot (like one produced by &lt;code&gt;cobalt::love.plot()&lt;/code&gt;), or a summary of balance (like providing the largest SMD and KS statistic observed across subgroups). Make sure your description of balance reflects the subgroups, e.g., by having separate tables or plots for each subgroup or clarifying that the statistics presented are averages or the worst case across subgroups.&lt;/li&gt;
&lt;li&gt;The outcome model you used, especially specifying the form of the model used and how/whether covariates entered the model. Also mention the method used to compute the standard errors (e.g., cluster-robust standard errors with pair membership as the clustering variable).&lt;/li&gt;
&lt;li&gt;Details of the marginal effects procedure used, including the package used, and the method to compute the standard errors (in this case, the delta method, which is the only method available in &lt;code&gt;{marginaleffects}&lt;/code&gt;).&lt;/li&gt;
&lt;li&gt;The treatment effect estimates along with their p-values and confidence intervals, both overall and within subgroups.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;references&#34; class=&#34;section level2 unnumbered&#34;&gt;
&lt;h2&gt;References&lt;/h2&gt;
&lt;div id=&#34;refs&#34; class=&#34;references csl-bib-body hanging-indent&#34;&gt;
&lt;div id=&#34;ref-austinIntroductionPropensityScore2011&#34; class=&#34;csl-entry&#34;&gt;
Austin, Peter C. 2011. &lt;span&gt;‚ÄúAn Introduction to Propensity Score Methods for Reducing the Effects of Confounding in Observational Studies.‚Äù&lt;/span&gt; &lt;em&gt;Multivariate Behavioral Research&lt;/em&gt; 46 (3): 399‚Äì424. &lt;a href=&#34;https://doi.org/10.1080/00273171.2011.568786&#34;&gt;https://doi.org/10.1080/00273171.2011.568786&lt;/a&gt;.
&lt;/div&gt;
&lt;div id=&#34;ref-greenExaminingModerationAnalyses2014&#34; class=&#34;csl-entry&#34;&gt;
Green, Kerry M., and Elizabeth A. Stuart. 2014. &lt;span&gt;‚ÄúExamining Moderation Analyses in Propensity Score Methods: &lt;span&gt;Application&lt;/span&gt; to Depression and Substance Use.‚Äù&lt;/span&gt; &lt;em&gt;Journal of Consulting and Clinical Psychology&lt;/em&gt;, Advances in &lt;span&gt;Data Analytic Methods&lt;/span&gt;, 82 (5): 773‚Äì83. &lt;a href=&#34;https://doi.org/10.1037/a0036515&#34;&gt;https://doi.org/10.1037/a0036515&lt;/a&gt;.
&lt;/div&gt;
&lt;div id=&#34;ref-greiferMatchingMethodsConfounder2021a&#34; class=&#34;csl-entry&#34;&gt;
Greifer, Noah, and Elizabeth A Stuart. 2021. &lt;span&gt;‚ÄúMatching &lt;span&gt;Methods&lt;/span&gt; for &lt;span&gt;Confounder Adjustment&lt;/span&gt;: &lt;span&gt;An Addition&lt;/span&gt; to the &lt;span&gt;Epidemiologist&lt;/span&gt;‚Äôs &lt;span&gt;Toolbox&lt;/span&gt;.‚Äù&lt;/span&gt; &lt;em&gt;Epidemiologic Reviews&lt;/em&gt;, June, mxab003. &lt;a href=&#34;https://doi.org/10.1093/epirev/mxab003&#34;&gt;https://doi.org/10.1093/epirev/mxab003&lt;/a&gt;.
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes footnotes-end-of-document&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;You might notices the mean differences for binary variables differ between the two outputs; that‚Äôs because &lt;code&gt;summary()&lt;/code&gt; standardizes the mean differences whereas &lt;code&gt;bal.tab()&lt;/code&gt; does not for binary variables. If you want standardized mean differences for binary variables from &lt;code&gt;bal.tab()&lt;/code&gt;, just add the argument &lt;code&gt;binary = &#34;std&#34;&lt;/code&gt;.&lt;a href=&#34;#fnref1&#34; class=&#34;footnote-back&#34;&gt;‚Ü©Ô∏é&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn2&#34;&gt;&lt;p&gt;Note: &lt;code&gt;rbind()&lt;/code&gt; must be used for this; functions from other packages, like &lt;code&gt;dplyr::bind_rows()&lt;/code&gt;, will not correctly preserve the subclass structure.&lt;a href=&#34;#fnref2&#34; class=&#34;footnote-back&#34;&gt;‚Ü©Ô∏é&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn3&#34;&gt;&lt;p&gt;This requires version 0.9.0 ore greater of &lt;code&gt;{marginaleffects}&lt;/code&gt;.&lt;a href=&#34;#fnref3&#34; class=&#34;footnote-back&#34;&gt;‚Ü©Ô∏é&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>
